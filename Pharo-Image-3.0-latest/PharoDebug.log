THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
25 November 2018 6:54:11.166428 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	ChangeBindingTest
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	ChangeBindingTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		category: 	#changeBindingTest
		selector: 	nil
		class: 	ChangeBindingTest
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		protocol: 	#changeBindingTest
		method: 	ChangeBindingTest>>#testChange
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(925630464)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		choice: 	true
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		aSymbol: 	#wantToChange
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		event: 	[(517@100) mouseDown red 3825000 nil]
		row: 	3
		anInteger: 	nil
		oldIndex: 	nil
		oldVal: 	nil
		valueKeeper: 	nil
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


PluggableIconListMorph(PluggableListMorph)>>mouseDown:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		evt: 	[(517@100) mouseDown red 3825000 nil]
		selectors: 	nil
		row: 	3
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


PluggableIconListMorph(Morph)>>handleMouseDown:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MouseButtonEvent>>sentTo:
	Receiver: [(517@100) mouseDown red 3825000 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableIconListMorph(735313920)
	Receiver's instance variables: 
		timeStamp: 	3825000
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(517@100)
		handler: 	a PluggableIconListMorph(735313920)
		wasHandled: 	true
		whichButton: 	4


PluggableIconListMorph(Morph)>>handleEvent:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PluggableIconListMorph(735313920)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a TransformMorph(477626368)
		morphs: 	an Array(a TransformMorph(477626368))
		handler: 	a PluggableIconListMorph(735313920)
		inside: 	false
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PluggableIconListMorph(735313920)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


PluggableIconListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PanelMorph(683671552)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a PluggableIconListMorph(735313920)
		morphs: 	an Array(a PanelMorph(631242752) a PluggableIconListMorph(735313920))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PanelMorph(683671552)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


PanelMorph(Morph)>>processEvent:using:
	Receiver: a PanelMorph(683671552)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@338.0)
		owner: 	a NautilusWindow(974913536)
		submorphs: 	an Array(a PanelMorph(631242752) a PluggableIconListMorph(735313920)...etc...
		fullBounds: 	(438@52) corner: (646@338)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (730333184) [sticky] 
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a NautilusWindow(974913536)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	11
		child: 	a PanelMorph(683671552)
		morphs: 	an Array(a WindowEdgeGripMorph(523763712) a WindowEdgeGripMorph(3481272...etc...
		handler: 	nil
		inside: 	nil
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a NautilusWindow(974913536)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


NautilusWindow(Morph)>>processEvent:using:
	Receiver: a NautilusWindow(974913536)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(221.0@24.0) corner: (1071.0@624.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a WindowEdgeGripMorph(523763712) a WindowEdgeGripMorph(3481...etc...
		fullBounds: 	(221@24) corner: (1071@624)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (62914560) [other:  (paneColor -> (Color r: 0.82300...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		labelString: 	'ChangeBindingTest>>#testChange'
		stripes: 	an Array(a Morph(980418560) a Morph(992215040))
		label: 	a LabelMorph(150208512)'ChangeBindingTest>>#testChange'
		closeBox: 	a MultistateButtonMorph(159383552)
		collapseBox: 	a MultistateButtonMorph(694943744)
		activeOnlyOnTop: 	true
		paneMorphs: 	an Array(a PanelMorph(911998976) a DropListMorph(1012137984) a Plug...etc...
		collapsedFrame: 	nil
		fullFrame: 	(221.0@24.0) corner: (1071.0@624.0)
		isCollapsed: 	false
		menuBox: 	a MultistateButtonMorph(606339072)
		mustNotClose: 	false
		labelWidgetAllowance: 	133
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1019215872)
		expandBox: 	a MultistateButtonMorph(1034682368)
		embeddable: 	nil
		announcer: 	an Announcer
		menuBuilder: 	nil
		isResizeable: 	true


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a WorldMorph(511705088) [world]
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a NautilusWindow(974913536)
		morphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Standa...etc...
		handler: 	a WorldMorph(511705088) [world]
		inside: 	nil
		lastHandler: 	nil
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


WorldMorph(Morph)>>processEvent:using:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@801)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Sta...etc...
		fullBounds: 	(0@0) corner: (1536@801)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph(Morph)>>processEvent:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@801)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Sta...etc...
		fullBounds: 	(0@0) corner: (1536@801)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		focusHolder: 	nil
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		evt: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(517@100) mouseDown red 3825000 nil]
		evtBuf: 	#(1 3825000 517 100 4 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1536@801)
		canvas: 	a FormCanvas on: DisplayScreen(1536x801x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an EditableDropListMorph(445644800))(a...etc...
		lastStepTime: 	1288356
		lastStepMessage: 	nil
		lastCycleTime: 	1288356
		alarms: 	a Heap()
		lastAlarmTime: 	1288356
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
PluggableIconListMorph(PluggableListMorph)>>mouseDown:
PluggableIconListMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
PluggableIconListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableIconListMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
NautilusWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
25 November 2018 6:54:21.568428 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	ChangeBindingTest
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	ChangeBindingTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		category: 	#changeBindingTest
		selector: 	nil
		class: 	ChangeBindingTest
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		protocol: 	#changeBindingTest
		method: 	ChangeBindingTest>>#testChange
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(925630464)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(114032640)
		secondArg: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(114032640)
		secondArg: 	a TextMorphForEditView(114032640)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(114032640)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(114032640)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(#accept on Ctrl + S do [ :morph | morph acceptContents ]
 nil n...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(114032640)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(114032640)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(114032640)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		timeStamp: 	3837140
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(292.0@73.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>at
25 November 2018 7:20:15.308923 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>doesNotUnderstand: #at
	Receiver: #(#n 10)
	Arguments and temporary variables: 
		aMessage: 	at
		exception: 	MessageNotUnderstood: Array>>at
		resumeValue: 	nil
	Receiver's instance variables: 
#(#n 10)

[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable at traceCr.
		oneVariable at: 2 traceCr ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		oneVariable: 	#(#n 10)
	Receiver's instance variables: 
nil

Array(SequenceableCollection)>>do:
	Receiver: #(#(#n 10))
	Arguments and temporary variables: 
		aBlock: 	[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable...etc...
		index: 	1
	Receiver's instance variables: 
#(#(#n 10))

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class ...etc...
		itsSelection: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symb...etc...
		itsSelectionString: 	'{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol cl...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ {{#n.
	10}}
		do: [ :oneVariable | 
			oneVariable ~= Symbol class...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(675020800)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(731119616)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(30.0@53.0) corner: (1490.0@727.0)
		owner: 	a SystemWindow(1026031616)
		submorphs: 	an Array(a TransformMorph(681574400))
		fullBounds: 	(30@53) corner: (1490@727)
		color: 	Color white
		extension: 	a MorphExtension (653787136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770965504)
		scroller: 	a TransformMorph(681574400)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(777519104)
		textMorph: 	a TextMorphForEditView(675020800)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 124)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(731119616)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(30.0@53.0) corner: (1490.0@727.0)
		owner: 	a SystemWindow(1026031616)
		submorphs: 	an Array(a TransformMorph(681574400))
		fullBounds: 	(30@53) corner: (1490@727)
		color: 	Color white
		extension: 	a MorphExtension (653787136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770965504)
		scroller: 	a TransformMorph(681574400)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(777519104)
		textMorph: 	a TextMorphForEditView(675020800)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 124)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(731119616)
		secondArg: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(731119616)
		secondArg: 	a PluggableTextMorph(731119616)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(731119616)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(731119616)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(731119616)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(731119616)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#TextMorphTab) ...etc...
		morph: 	a PluggableTextMorph(731119616)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#TextMorphTab) ...etc...
		morph: 	a PluggableTextMorph(731119616)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(731119616)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(675020800)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(675020800)
	Receiver's instance variables: 
		timeStamp: 	5390843
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-16@9.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(675020800)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(18@63) corner: (34@79)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(675020800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(18@63) mouseOver nil nil]
		targetOffset: 	(752@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5390328 18 63 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1520@785)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(1026031616) a Syst...etc...
		fullBounds: 	(0@0) corner: (1520@785)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(675020800)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(18@63) corner: (34@79)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(675020800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(18@63) mouseOver nil nil]
		targetOffset: 	(752@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5390328 18 63 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
Array(Object)>>doesNotUnderstand: #at
[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable at traceCr.
		oneVariable at: 2 traceCr ] ] in UndefinedObject>>DoIt
Array(SequenceableCollection)>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:16:47.327489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->1
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	1


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#a...etc...
		itsSelection: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding trac...etc...
		itsSelectionString: 	'|bloque|
bloque:=[#a binding traceCr. #b binding traceCr]....etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ]....etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 125)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 125)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	8782843
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-41@ -26.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(712245248)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1038@375) corner: (1054@391)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(712245248)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1038@375) mouseOver nil nil]
		targetOffset: 	(183@93.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 8782281 1038 375 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:19:43.477489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->1
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	1


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

[ #a bindTo: 1 in: bloque ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].

...etc...
		itsSelection: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding tr...etc...
		itsSelectionString: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque c |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	8959015
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-29@14.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
[ #a bindTo: 1 in: bloque ] in UndefinedObject>>DoIt
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:22:56.688489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->2
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	2


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].

...etc...
		itsSelection: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding tr...etc...
		itsSelectionString: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque c |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a ScrollBar(1056178176) a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 163)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a ScrollBar(1056178176) a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 163)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	9152234
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-16@12)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(712245248)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1063@413) corner: (1079@429)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(712245248)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1063@413) mouseOver nil nil]
		targetOffset: 	(171@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 9151734 1063 413 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:47:45.571084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:51:33.798084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:54:14.910084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:54:57.284084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:56:52.832084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:57:21.453084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:57:57.634084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 9:58:34.486084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 9:59:29.333084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 10:00:01.672084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 10:01:15.861084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:02:01.918084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:03:04.687084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:03:40.208084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:04:37.990524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:06:25.661524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:06:52.797524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:08:11.490524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
25 November 2018 10:08:15.050524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

PracticaTest(TestAsserter)>>assert:
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
PracticaTest(TestAsserter)>>assert:
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:08:54.808524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:10:01.431524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:10:14.264524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:11:05.963524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 10:12:00.341524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

Error: No binding for b

25 November 2018 10:54:44.737407 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:29:22.04256 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:31:29.36156 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:37:11.73456 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#b)
		aBlock: 	[ self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b

	Receiver's instance variables: 

a PROG



PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:

	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...

	Arguments and temporary variables: 

		aTestCase: 	PracticaTest>>#testVariableBinding

	Receiver's instance variables: 

		timeStamp: 	2018-11-28T15:37:11.59356+01:00

		failures: 	a Set()

		errors: 	an OrderedCollection()

		passed: 	an OrderedCollection()

		skipped: 	an OrderedCollection()





BlockClosure>>on:do:

	Receiver: [ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase anno...etc...

	Arguments and temporary variables: 

		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	TestResult>>runCase:

		startpc: 	70

		numArgs: 	0





TestResult>>runCase:

	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...

	Arguments and temporary variables: 

		aTestCase: 	PracticaTest>>#testVariableBinding

	Receiver's instance variables: 

		timeStamp: 	2018-11-28T15:37:11.59356+01:00

		failures: 	a Set()

		errors: 	an OrderedCollection()

		passed: 	an OrderedCollection()

		skipped: 	an OrderedCollection()





PracticaTest(TestCase)>>run:

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ self run: result ] in PracticaTest(TestCase)>>run

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ self run: result ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>run

		startpc: 	46

		numArgs: 	0





PracticaTest(TestCase)>>run

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>run:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





PackageTreeNautilusUI(NautilusUI)>>runTestForAMethodWithAnHalt:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

		aMethod: 	PracticaTest>>#testVariableBinding
		testMethod: 	PracticaTest>>#testVariableBinding
		color: 	nil
		vScroll: 	0.0
		testClass: 	PracticaTest
		testResult: 	nil

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ self runTestForAMethodWithAnHalt: aMethod ] in [ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt: aMethod ] fork.
		shouldAnnounce := false.
		TestAsserter classForTestResult new ]
	ifFalse: [ 
		TestAsserter classForTestResult new
			addFailure: (testClass selector: testMethod selector);
			yourself ] ] in [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ self runTestForAMethodWithAnHalt: aMethod ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	[ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt...etc...

		startpc: 	275

		numArgs: 	0







--- The full stack ---

PROG>>addVariables:in:

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:

BlockClosure>>on:do:

TestResult>>runCase:

PracticaTest(TestCase)>>run:

[ self run: result ] in PracticaTest(TestCase)>>run

BlockClosure>>ensure:

PracticaTest(TestCase)>>run

PracticaTest class(TestCase class)>>run:

PackageTreeNautilusUI(NautilusUI)>>runTestForAMethodWithAnHalt:

[ self runTestForAMethodWithAnHalt: aMethod ] in [ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt: aMethod ] fork.
		shouldAnnounce := false.
		TestAsserter classForTestResult new ]
	ifFalse: [ 
		TestAsserter classForTestResult new
			addFailure: (testClass selector: testMethod selector);
			yourself ] ] in [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:39:14.08756 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#b)
		aBlock: 	[ #b binding ]
		newBlock: 	nil
		lastVariable: 	#b

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1535625

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(3.0@19.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(219938816) a ...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendKeyboardEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addVariables:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:39:38.55856 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1560218

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-17.0@ -4.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(687@477.0) corner: (703@493.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@477) mouseOver CTRL nil nil]

		targetOffset: 	(93.0@85.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1559812 687 477 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(687@477.0) corner: (703@493.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@477) mouseOver CTRL nil nil]

		targetOffset: 	(93.0@85.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1559812 687 477 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:40:34.50856 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1616171

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-50.0@ -3.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(654@478.0) corner: (670@494.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(654@478) mouseOver nil nil]

		targetOffset: 	(107.0@78.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1615593 654 478 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(654@478.0) corner: (670@494.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(654@478) mouseOver nil nil]

		targetOffset: 	(107.0@78.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1615593 654 478 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:41:28.10456 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1669765

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-22.0@11.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(682@492.0) corner: (698@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(682@492) mouseOver CTRL nil nil]

		targetOffset: 	(109.0@97.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1668890 682 492 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(682@492.0) corner: (698@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(682@492) mouseOver CTRL nil nil]

		targetOffset: 	(109.0@97.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1668890 682 492 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:42:41.93156 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1743593

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-26.0@1.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(678@482.0) corner: (694@498.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@482) mouseOver nil nil]

		targetOffset: 	(183.0@92.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1742921 678 482 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(678@482.0) corner: (694@498.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@482) mouseOver nil nil]

		targetOffset: 	(183.0@92.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1742921 678 482 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:48:52.54356 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 127)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 127)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	2114078

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-72.0@0.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(347340800) a ...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendKeyboardEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>handleEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for RETURN

28 November 2018 5:28:38.337913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #RETURN

	Arguments and temporary variables: 

		aString: 	'No binding for RETURN'

	Receiver's instance variables: 

#RETURN



ByteSymbol(Symbol)>>binding

	Receiver: #RETURN

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	a PROG
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	nil

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	2

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0 ...etc...
		itsSelection: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBi...etc...
		itsSelectionString: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit: {#n}
		do:
			{{#label1.
			[ #n changeBinding: 0...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 401)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 401)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	4500734

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-134@ -52.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(90@331.0) corner: (106@347.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(90@331) mouseOver nil nil]

		targetOffset: 	(155@149)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 4500156 90 331 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(90@331.0) corner: (106@347.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(90@331) mouseOver nil nil]

		targetOffset: 	(155@149)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 4500156 90 331 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:38:00.451913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ #n changeBinding: 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	46

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ #n changeBinding: 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ #n changeBinding: 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chang...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n c...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ #n ...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 101)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 101)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5062875

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-10@6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:38:27.508913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	38

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } in...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ 0 ]...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5089921

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-111@5.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:39:42.471913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	38

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } in...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ 0 ]...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5164890

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-148@ -1.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for n

28 November 2018 5:42:43.519913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #n

	Arguments and temporary variables: 

		aString: 	'No binding for n'

	Receiver's instance variables: 

#n



ByteSymbol(Symbol)>>binding

	Receiver: #n

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#n



[ #n binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #n binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #n binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode:...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #n binding ].
	prog
		addCode:...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5345937

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(181@49.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(702@622.0) corner: (718@638.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(702@622.0) corner: (718@638.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(710@631) mouseOver nil nil]

		targetOffset: 	(183.0@204.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5333218 710 631 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(702@622.0) corner: (718@638.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(702@622.0) corner: (718@638.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(710@631) mouseOver nil nil]

		targetOffset: 	(183.0@204.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5333218 710 631 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #n binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:06.691913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog add...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	prog
		add...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 107)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 107)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5369109

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-15@9.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(514@591.0) corner: (530@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(514@591) mouseOver nil nil]

		targetOffset: 	(79.0@93.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5368703 514 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(514@591.0) corner: (530@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(514@591) mouseOver nil nil]

		targetOffset: 	(79.0@93.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5368703 514 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:20.373913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5382781

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-58@ -33.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(471@549.0) corner: (487@565.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(471@549) mouseOver nil nil]

		targetOffset: 	(57@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5382312 471 549 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(471@549.0) corner: (487@565.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(471@549) mouseOver nil nil]

		targetOffset: 	(57@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5382312 471 549 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:48.405913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5410843

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-21@9.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(508@591.0) corner: (524@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(508@591) mouseOver nil nil]

		targetOffset: 	(97@81.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5410187 508 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a SpecW...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(508@591.0) corner: (524@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(508@591) mouseOver nil nil]

		targetOffset: 	(97@81.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5410187 508 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:25:25.510136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11507906

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-17@6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(512@588.0) corner: (528@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(512@588) mouseOver nil nil]

		targetOffset: 	(78.0@87.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11506796 512 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(512@588.0) corner: (528@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(512@588) mouseOver nil nil]

		targetOffset: 	(78.0@87.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11506796 512 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:31:34.521136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 484)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 484)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11876937

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-37@ -77.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:31:59.654136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11902062

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-47@ -23.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:33:27.979136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11990390

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-33@ -90.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:34:31.117136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12053531

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-18@ -58.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:35:44.371136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12126781

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-48@34.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

SubscriptOutOfBounds: 0

28 November 2018 7:45:08.248136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>errorSubscriptBounds:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(Object)>>at:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(SequenceableCollection)>>last

	Receiver: #()

	Arguments and temporary variables: 



	Receiver's instance variables: 

#()



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ...etc...
		lastLine: 	an Array(#label1 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: n...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 207)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 207)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12690671

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(149@116.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(670@689.0) corner: (686@705.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(670@689.0) corner: (686@705.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	a MouseClickState[#firstClickUp]

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@698) mouseOver nil nil]

		targetOffset: 	(149@116)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12689484 678 698 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>errorSubscriptBounds:

Array(Object)>>at:

Array(SequenceableCollection)>>last

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:45:34.851136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

#label7



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ #label1 binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		lableLine: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0 ...etc...
		itsSelection: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBi...etc...
		itsSelectionString: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit: {#n}
		do:
			{{#label1.
			[ #n changeBinding: 0...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 399)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 399)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:45:50.380136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ 
#label1 binding.
#label2 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

#label2



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 205)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 205)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12732796

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-3@ -6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ 
#label1 binding.
#label2 binding ] in UndefinedObject>>DoIt

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label2

28 November 2018 7:49:06.475136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label2

	Arguments and temporary variables: 

		aString: 	'No binding for label2'

	Receiver's instance variables: 

#label2



ByteSymbol(Symbol)>>binding

	Receiver: #label2

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label2



[ 
#label1 binding traceCr.
#label2 binding traceCr ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

#label1



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #l...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding tr...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 167)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 167)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12928906

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-54@ -40.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ 
#label1 binding traceCr.
#label2 binding traceCr ] in UndefinedObject>>DoIt

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



