THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
25 November 2018 6:54:11.166428 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	ChangeBindingTest
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	ChangeBindingTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		category: 	#changeBindingTest
		selector: 	nil
		class: 	ChangeBindingTest
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		protocol: 	#changeBindingTest
		method: 	ChangeBindingTest>>#testChange
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(925630464)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		choice: 	true
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		aSymbol: 	#wantToChange
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		event: 	[(517@100) mouseDown red 3825000 nil]
		row: 	3
		anInteger: 	nil
		oldIndex: 	nil
		oldVal: 	nil
		valueKeeper: 	nil
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


PluggableIconListMorph(PluggableListMorph)>>mouseDown:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		evt: 	[(517@100) mouseDown red 3825000 nil]
		selectors: 	nil
		row: 	3
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


PluggableIconListMorph(Morph)>>handleMouseDown:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MouseButtonEvent>>sentTo:
	Receiver: [(517@100) mouseDown red 3825000 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableIconListMorph(735313920)
	Receiver's instance variables: 
		timeStamp: 	3825000
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(517@100)
		handler: 	a PluggableIconListMorph(735313920)
		wasHandled: 	true
		whichButton: 	4


PluggableIconListMorph(Morph)>>handleEvent:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PluggableIconListMorph(735313920)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a TransformMorph(477626368)
		morphs: 	an Array(a TransformMorph(477626368))
		handler: 	a PluggableIconListMorph(735313920)
		inside: 	false
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PluggableIconListMorph(735313920)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


PluggableIconListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableIconListMorph(735313920)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@309.0)
		owner: 	a PanelMorph(683671552)
		submorphs: 	an Array(a TransformMorph(477626368))
		fullBounds: 	(438@52) corner: (646@309)
		color: 	Color white
		extension: 	a MorphExtension (95420416) [other:  (dropEnabled -> true) (dragEnab...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(765984768)
		scroller: 	a TransformMorph(477626368)
		getMenuSelector: 	#menu2:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(651952128)
		list: 	nil
		getListSelector: 	nil
		getListSizeSelector: 	#listSize2
		getListElementSelector: 	#listElement2:
		getIndexSelector: 	#selected2
		setIndexSelector: 	#selected2:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	#doubleClick2
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyMorphListMorph(533725184)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	#dropInList2:inARow:
		wantsDropSelector: 	nil
		wrapSelector: 	#listWrapper2:
		searchedElement: 	nil
		multipleSelection: 	true
		dragOnOrOff: 	nil
		setSelectionListSelector: 	#listSelection2At:put:
		getSelectionListSelector: 	#listSelection2At:
		resetListSelector: 	#resetListSelection2
		keystrokeSelector: 	#keyPressedOnList2:shifted:
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	4
		canMove: 	false
		getIconSelector: 	#listIcon2:


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PanelMorph(683671552)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a PluggableIconListMorph(735313920)
		morphs: 	an Array(a PanelMorph(631242752) a PluggableIconListMorph(735313920))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a PanelMorph(683671552)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


PanelMorph(Morph)>>processEvent:using:
	Receiver: a PanelMorph(683671552)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(438.0@52.0) corner: (646.0@338.0)
		owner: 	a NautilusWindow(974913536)
		submorphs: 	an Array(a PanelMorph(631242752) a PluggableIconListMorph(735313920)...etc...
		fullBounds: 	(438@52) corner: (646@338)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (730333184) [sticky] 
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a NautilusWindow(974913536)
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	11
		child: 	a PanelMorph(683671552)
		morphs: 	an Array(a WindowEdgeGripMorph(523763712) a WindowEdgeGripMorph(3481272...etc...
		handler: 	nil
		inside: 	nil
		lastHandler: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a NautilusWindow(974913536)
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


NautilusWindow(Morph)>>processEvent:using:
	Receiver: a NautilusWindow(974913536)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(221.0@24.0) corner: (1071.0@624.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a WindowEdgeGripMorph(523763712) a WindowEdgeGripMorph(3481...etc...
		fullBounds: 	(221@24) corner: (1071@624)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (62914560) [other:  (paneColor -> (Color r: 0.82300...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		labelString: 	'ChangeBindingTest>>#testChange'
		stripes: 	an Array(a Morph(980418560) a Morph(992215040))
		label: 	a LabelMorph(150208512)'ChangeBindingTest>>#testChange'
		closeBox: 	a MultistateButtonMorph(159383552)
		collapseBox: 	a MultistateButtonMorph(694943744)
		activeOnlyOnTop: 	true
		paneMorphs: 	an Array(a PanelMorph(911998976) a DropListMorph(1012137984) a Plug...etc...
		collapsedFrame: 	nil
		fullFrame: 	(221.0@24.0) corner: (1071.0@624.0)
		isCollapsed: 	false
		menuBox: 	a MultistateButtonMorph(606339072)
		mustNotClose: 	false
		labelWidgetAllowance: 	133
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1019215872)
		expandBox: 	a MultistateButtonMorph(1034682368)
		embeddable: 	nil
		announcer: 	an Announcer
		menuBuilder: 	nil
		isResizeable: 	true


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a WorldMorph(511705088) [world]
		globalPt: 	(517@100)
		localEvt: 	[(517@100) mouseDown red 3825000 nil]
		index: 	2
		child: 	a NautilusWindow(974913536)
		morphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Standa...etc...
		handler: 	a WorldMorph(511705088) [world]
		inside: 	nil
		lastHandler: 	nil
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		aMorph: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		lastType: 	#mouseDown
		lastDispatch: 	#dispatchMouseDown:with:


WorldMorph(Morph)>>processEvent:using:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@801)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Sta...etc...
		fullBounds: 	(0@0) corner: (1536@801)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph(Morph)>>processEvent:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@801)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(974913536) a Sta...etc...
		fullBounds: 	(0@0) corner: (1536@801)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		focusHolder: 	nil
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(517@100) mouseDown red 3825000 nil]
		evt: 	[(517@100) mouseDown red 3825000 nil]
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(517@100) mouseDown red 3825000 nil]
		evtBuf: 	#(1 3825000 517 100 4 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(497@147) corner: (513@163)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(497@147) corner: (513@163)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(735313920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(497@147) mouseOver nil nil]
		targetOffset: 	(39.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 3826734 497 147 0 0 1 1)
		lastKeyScanCode: 	88
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1536@801)
		canvas: 	a FormCanvas on: DisplayScreen(1536x801x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an EditableDropListMorph(445644800))(a...etc...
		lastStepTime: 	1288356
		lastStepMessage: 	nil
		lastCycleTime: 	1288356
		alarms: 	a Heap()
		lastAlarmTime: 	1288356
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
PluggableIconListMorph(PluggableListMorph)>>mouseDownOnMultiple:forRow:
PluggableIconListMorph(PluggableListMorph)>>mouseDown:
PluggableIconListMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
PluggableIconListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableIconListMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
NautilusWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
25 November 2018 6:54:21.568428 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>errorSubscriptBounds:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(Object)>>at:
	Receiver: #()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
#()

Array(SequenceableCollection)>>first
	Receiver: #()
	Arguments and temporary variables: 

	Receiver's instance variables: 
#()

PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	ChangeBindingTest
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		selector: 	nil
		existingMethod: 	nil
		targetClass: 	ChangeBindingTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aCategory: 	#changeBindingTest
		aString: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		category: 	#changeBindingTest
		selector: 	nil
		class: 	ChangeBindingTest
		scroll: 	0.0
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


MethodDefinitionAcceptor>>accept:notifying:
	Receiver: a MethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	''
		aController: 	a PluggableTextMorphWithLimits(925630464)
		protocol: 	#changeBindingTest
		method: 	ChangeBindingTest>>#testChange
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ''
		aController: 	a PluggableTextMorphWithLimits(925630464)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PracticaTest
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(ChangeBindingTest->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{ChangeBindingTest. PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ''
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3.0@0.0)
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(925630464)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(226.0@342.0) corner: (1042.0@619.0)
		owner: 	a MultipleMethodsEditor(637534208)
		submorphs: 	an Array(an AlphaImageMorph(236716032) a TransformMorph(882376704))
		fullBounds: 	(226@342) corner: (1042@619)
		color: 	Color white
		extension: 	a MorphExtension (92798976) [eventHandler = a MorphicEventHandler]  ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(967311360)
		scroller: 	a TransformMorph(882376704)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(936116224)
		textMorph: 	a TextMorphForEditView(114032640)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(236716032)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(114032640)
		secondArg: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(114032640)
		secondArg: 	a TextMorphForEditView(114032640)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(114032640)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(114032640)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	1
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(#accept on Ctrl + S do [ :morph | morph acceptContents ]
 nil n...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(114032640)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(114032640)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(114032640)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(114032640)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(114032640)
	Receiver's instance variables: 
		timeStamp: 	3837140
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(292.0@73.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(114032640)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@18)
		owner: 	a TransformMorph(882376704)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@18)
		color: 	Color black
		extension: 	a MorphExtension (180879360) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ''
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(925630464)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Array(SequenceableCollection)>>first
PackageTreeNautilusUI(AbstractTool)>>compileANewMethodInClass:categorized:from:notifyng:
PackageTreeNautilusUI(NautilusUI)>>compileAMethodFromCategory:withSource:notifying:
MethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Array>>at
25 November 2018 7:20:15.308923 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

Array(Object)>>doesNotUnderstand: #at
	Receiver: #(#n 10)
	Arguments and temporary variables: 
		aMessage: 	at
		exception: 	MessageNotUnderstood: Array>>at
		resumeValue: 	nil
	Receiver's instance variables: 
#(#n 10)

[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable at traceCr.
		oneVariable at: 2 traceCr ] ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		oneVariable: 	#(#n 10)
	Receiver's instance variables: 
nil

Array(SequenceableCollection)>>do:
	Receiver: #(#(#n 10))
	Arguments and temporary variables: 
		aBlock: 	[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable...etc...
		index: 	1
	Receiver's instance variables: 
#(#(#n 10))

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class ...etc...
		itsSelection: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symb...etc...
		itsSelectionString: 	'{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol cl...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ {{#n.
	10}}
		do: [ :oneVariable | 
			oneVariable ~= Symbol class...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(675020800)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(731119616)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(30.0@53.0) corner: (1490.0@727.0)
		owner: 	a SystemWindow(1026031616)
		submorphs: 	an Array(a TransformMorph(681574400))
		fullBounds: 	(30@53) corner: (1490@727)
		color: 	Color white
		extension: 	a MorphExtension (653787136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770965504)
		scroller: 	a TransformMorph(681574400)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(777519104)
		textMorph: 	a TextMorphForEditView(675020800)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 124)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(731119616)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(30.0@53.0) corner: (1490.0@727.0)
		owner: 	a SystemWindow(1026031616)
		submorphs: 	an Array(a TransformMorph(681574400))
		fullBounds: 	(30@53) corner: (1490@727)
		color: 	Color white
		extension: 	a MorphExtension (653787136) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770965504)
		scroller: 	a TransformMorph(681574400)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(777519104)
		textMorph: 	a TextMorphForEditView(675020800)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 124)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(731119616)
		secondArg: 	a PluggableTextMorph(731119616)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(731119616)
		secondArg: 	a PluggableTextMorph(731119616)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(731119616)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(731119616)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(731119616)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(731119616)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#TextMorphTab) ...etc...
		morph: 	a PluggableTextMorph(731119616)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextEditor) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextEditor) aKMCategoryTarget(#TextMorphTab) ...etc...
		morph: 	a PluggableTextMorph(731119616)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(731119616)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(675020800)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(675020800)
	Receiver's instance variables: 
		timeStamp: 	5390843
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-16@9.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(675020800)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1452@18)
		owner: 	a TransformMorph(681574400)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (1452@18)
		color: 	Color black
		extension: 	a MorphExtension (711720960) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '{{ #n . 10} } do: [ :oneVariable| oneVariable ~= Symbol class...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: Color black
		editView: 	a PluggableTextMorph(731119616)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(675020800)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(18@63) corner: (34@79)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(675020800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(18@63) mouseOver nil nil]
		targetOffset: 	(752@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5390328 18 63 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1520@785)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(1026031616) a Syst...etc...
		fullBounds: 	(0@0) corner: (1520@785)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(675020800)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(18@63) corner: (34@79)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(675020800)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(18@63) mouseOver nil nil]
		targetOffset: 	(752@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5390328 18 63 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
Array(Object)>>doesNotUnderstand: #at
[ :oneVariable | 
oneVariable ~= Symbol class
	ifTrue: [ 
		oneVariable at traceCr.
		oneVariable at: 2 traceCr ] ] in UndefinedObject>>DoIt
Array(SequenceableCollection)>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:16:47.327489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->1
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	1


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#a...etc...
		itsSelection: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding trac...etc...
		itsSelectionString: 	'|bloque|
bloque:=[#a binding traceCr. #b binding traceCr]....etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ]....etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 125)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 125)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	8782843
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-41@ -26.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque|
bloque:=[#a binding traceCr. #b binding traceCr].

#...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(712245248)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1038@375) corner: (1054@391)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(712245248)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1038@375) mouseOver nil nil]
		targetOffset: 	(183@93.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 8782281 1038 375 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:19:43.477489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->1
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	1


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	1
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

[ #a bindTo: 1 in: bloque ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].

...etc...
		itsSelection: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding tr...etc...
		itsSelectionString: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque c |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 121)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	8959015
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-29@14.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@98)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@98)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
[ #a bindTo: 1 in: bloque ] in UndefinedObject>>DoIt
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 8:22:56.688489 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

Binding>>of:to:in:
	Receiver: #a->2
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		key: 	#a
		value: 	2


Binding class>>of:to:in:
	Receiver: Binding
	Arguments and temporary variables: 
		aSymbol: 	#a
		aValue: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
		superclass: 	Association
		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Binding
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#DeutschByte
		traitComposition: 	{}
		localSelectors: 	nil


ByteSymbol(Symbol)>>bindTo:in:
	Receiver: #a
	Arguments and temporary variables: 
		value: 	2
		aBlock: 	[ 
#a binding traceCr.
#b binding traceCr ]
	Receiver's instance variables: 
#a

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		bloque: 	[ 
#a binding traceCr.
#b binding traceCr ]
		c: 	[ #a bindTo: 1 in: bloque ]
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].

...etc...
		itsSelection: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding tr...etc...
		itsSelectionString: 	'|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	| bloque c |
	bloque := [ 
	#a binding traceCr.
	#b binding traceCr ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(712245248)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a ScrollBar(1056178176) a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 163)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(1075.0@400.0) corner: (1515.0@567.0)
		owner: 	a SystemWindow(1064828928)
		submorphs: 	an Array(a ScrollBar(1056178176) a TransformMorph(863502336))
		fullBounds: 	(1075@400) corner: (1515@567)
		color: 	Color white
		extension: 	a MorphExtension (691011584) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(863502336)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(971505664)
		textMorph: 	a TextMorphForEditView(712245248)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 163)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(712245248)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(712245248)
	Receiver's instance variables: 
		timeStamp: 	9152234
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-16@12)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(712245248)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(863502336)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (773062656) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '|bloque c|
bloque:=[#a binding traceCr. #b binding traceCr].
...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(712245248)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1063@413) corner: (1079@429)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(712245248)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1063@413) mouseOver nil nil]
		targetOffset: 	(171@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 9151734 1063 413 0 0 0 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
#a binding traceCr.
#b binding traceCr ] in UndefinedObject>>DoIt
Binding>>of:to:in:
Binding class>>of:to:in:
ByteSymbol(Symbol)>>bindTo:in:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:47:45.571084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:51:33.798084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:54:14.910084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:54:57.284084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:56:52.832084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:57:21.453084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 9:57:57.634084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 9:58:34.486084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 9:59:29.333084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 10:00:01.672084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteSymbol class>>TraceCr
25 November 2018 10:01:15.861084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
	Receiver: ByteSymbol
	Arguments and temporary variables: 
		aMessage: 	TraceCr
		exception: 	MessageNotUnderstood: ByteSymbol class>>TraceCr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Symbol
		methodDict: 	a MethodDictionary(#asByteArray->ByteSymbol>>#asByteArray #asKmCate...etc...
		format: 	1026
		layout: 	a ByteLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ByteSymbol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Strings'
		traitComposition: 	{}
		localSelectors: 	nil


PROG>>addVariables:in:
	Receiver: a PROG
	Arguments and temporary variables: 
		someVariablesArray: 	#(#(#a 1) #b)
		aBlock: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b
	Receiver's instance variables: 
a PROG

PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol class(Object)>>doesNotUnderstand: #TraceCr
PROG>>addVariables:in:
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:02:01.918084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:03:04.687084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:03:40.208084 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:04:37.990524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:06:25.661524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:06:52.797524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:08:11.490524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
25 November 2018 10:08:15.050524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

PracticaTest(TestAsserter)>>assert:
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = 1.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
PracticaTest(TestAsserter)>>assert:
[ 
self assert: #a binding = 1.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:08:54.808524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:10:01.431524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->true PracticaTest->false )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:10:14.264524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(526909440)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(1008992256)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a RPackage(Practica)->true )
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(666632192)
		list2: 	a PluggableIconListMorph(12320768)
		sourceCodePanel: 	a PanelMorph(871366656)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(861929472)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(1008992256...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(563347456)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(934019072)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for a
25 November 2018 10:11:05.963524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #a
	Arguments and temporary variables: 
		aString: 	'No binding for a'
	Receiver's instance variables: 
#a

ByteSymbol(Symbol)>>binding
	Receiver: #a
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#a

[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ 
self assert: #a binding = nil.
self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ 
self assert: #a binding = nil.
self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: No binding for b
25 November 2018 10:12:00.341524 pm

VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30864]

ByteSymbol(Object)>>error:
	Receiver: #b
	Arguments and temporary variables: 
		aString: 	'No binding for b'
	Receiver's instance variables: 
#b

ByteSymbol(Symbol)>>binding
	Receiver: #b
	Arguments and temporary variables: 
		context: 	nil
	Receiver's instance variables: 
#b

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest>>testVariableBinding
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 
		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG
	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest(TestCase)>>performTest
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PracticaTest(TestCase)>>runCase
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ (self class selector: testSelector) runCase ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PracticaTest(TestCase)>>debug
		startpc: 	45
		numArgs: 	0


PracticaTest(TestCase)>>debug
	Receiver: PracticaTest>>#testVariableBinding
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVariableBinding
		expectedFails: 	nil


PracticaTest class(TestCase class)>>debug:
	Receiver: PracticaTest
	Arguments and temporary variables: 
		aSymbol: 	#testVariableBinding
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PracticaTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica
		traitComposition: 	{}
		localSelectors: 	nil
		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...


[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(974913536)
		hierarchyClass: 	PROG
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )
		list: 	a MorphTreeMorph(1018167296)
		list2: 	a PluggableIconListMorph(735313920)
		sourceCodePanel: 	a PanelMorph(775946240)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(911998976)
		list2Elements: 	{PROG. PracticaTest. Symbol}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(1027604480)


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...
		startpc: 	236
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Symbol)>>binding
[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding
PracticaTest>>testVariableBinding
PracticaTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase
BlockClosure>>ensure:
PracticaTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug
BlockClosure>>ensure:
PracticaTest(TestCase)>>debug
PracticaTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

Error: No binding for b

25 November 2018 10:54:44.737407 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:29:22.04256 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:31:29.36156 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ (self class selector: testSelector) runCase ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>debug

		startpc: 	45

		numArgs: 	0





PracticaTest(TestCase)>>debug

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>debug:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := tes...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:pr...etc...

		startpc: 	236

		numArgs: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ self assert: #b binding = nil ] in PracticaTest>>testVariableBinding

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ (self class selector: testSelector) runCase ] in PracticaTest(TestCase)>>debug

BlockClosure>>ensure:

PracticaTest(TestCase)>>debug

PracticaTest class(TestCase class)>>debug:

[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:37:11.73456 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#b)
		aBlock: 	[ self assert: #b binding = nil ]
		newBlock: 	nil
		lastVariable: 	#b

	Receiver's instance variables: 

a PROG



PracticaTest>>testVariableBinding

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		block: 	[ self assert: #b binding = nil ]
		prog: 	a PROG

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest(TestCase)>>performTest

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ 
self setUp.
self performTest ]

	Arguments and temporary variables: 

		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>runCase

		startpc: 	57

		numArgs: 	0





PracticaTest(TestCase)>>runCase

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 



	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:

	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...

	Arguments and temporary variables: 

		aTestCase: 	PracticaTest>>#testVariableBinding

	Receiver's instance variables: 

		timeStamp: 	2018-11-28T15:37:11.59356+01:00

		failures: 	a Set()

		errors: 	an OrderedCollection()

		passed: 	an OrderedCollection()

		skipped: 	an OrderedCollection()





BlockClosure>>on:do:

	Receiver: [ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase anno...etc...

	Arguments and temporary variables: 

		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	TestResult>>runCase:

		startpc: 	70

		numArgs: 	0





TestResult>>runCase:

	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...

	Arguments and temporary variables: 

		aTestCase: 	PracticaTest>>#testVariableBinding

	Receiver's instance variables: 

		timeStamp: 	2018-11-28T15:37:11.59356+01:00

		failures: 	a Set()

		errors: 	an OrderedCollection()

		passed: 	an OrderedCollection()

		skipped: 	an OrderedCollection()





PracticaTest(TestCase)>>run:

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





[ self run: result ] in PracticaTest(TestCase)>>run

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





BlockClosure>>ensure:

	Receiver: [ self run: result ]

	Arguments and temporary variables: 

		aBlock: 	[ self classForTestResource resetResources: self resources ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	PracticaTest(TestCase)>>run

		startpc: 	46

		numArgs: 	0





PracticaTest(TestCase)>>run

	Receiver: PracticaTest>>#testVariableBinding

	Arguments and temporary variables: 

		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...

	Receiver's instance variables: 

		testSelector: 	#testVariableBinding

		expectedFails: 	nil





PracticaTest class(TestCase class)>>run:

	Receiver: PracticaTest

	Arguments and temporary variables: 

		aSymbol: 	#testVariableBinding

	Receiver's instance variables: 

		superclass: 	TestCase

		methodDict: 	a MethodDictionary(#testChangeBinding->PracticaTest>>#testChangeBin...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PracticaTest

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil

		history: 	a Dictionary(#errors->a Set(#testVariableBinding) #failures->a Set() #...etc...





PackageTreeNautilusUI(NautilusUI)>>runTestForAMethodWithAnHalt:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

		aMethod: 	PracticaTest>>#testVariableBinding
		testMethod: 	PracticaTest>>#testVariableBinding
		color: 	nil
		vScroll: 	0.0
		testClass: 	PracticaTest
		testResult: 	nil

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ self runTestForAMethodWithAnHalt: aMethod ] in [ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt: aMethod ] fork.
		shouldAnnounce := false.
		TestAsserter classForTestResult new ]
	ifFalse: [ 
		TestAsserter classForTestResult new
			addFailure: (testClass selector: testMethod selector);
			yourself ] ] in [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

	Receiver: a PackageTreeNautilusUI

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...

		model: 	a PackageTreeNautilus

		window: 	a NautilusWindow(974913536)

		hierarchyClass: 	PROG

		cachedHierarchy: 	a SortHierarchically

		sourceTextArea: 	a PluggableTextMorphWithLimits(925630464)

		groupsSelection: 	a Dictionary()

		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...

		classesSelection: 	a Dictionary(PROG->false PracticaTest->true )

		list: 	a MorphTreeMorph(1018167296)

		list2: 	a PluggableIconListMorph(735313920)

		sourceCodePanel: 	a PanelMorph(775946240)

		commentTextArea: 	nil

		currentDisplayChoice: 	#SourceCode

		sourceTextAreaLimit: 	350

		sourceCodeContainer: 	a PanelMorph(911998976)

		list2Elements: 	{PROG. PracticaTest. Symbol}

		listElements: 	nil

		shouldUpdateTitle: 	true

		testSemaphore: 	a Semaphore()

		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(925630464)...etc...

		multipleMethodsEditor: 	a MultipleMethodsEditor(637534208)

		contentSelection: 	nil

		acceptor: 	a MethodDefinitionAcceptor

		classifier: 	a MethodClassifier

		categoryWidget: 	a CategoryWidget

		methodWidget: 	a MethodWidget

		packagePattern: 	a RxMatcher

		searchWidget: 	a SearchMorph(1027604480)





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ self runTestForAMethodWithAnHalt: aMethod ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	[ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt...etc...

		startpc: 	275

		numArgs: 	0







--- The full stack ---

PROG>>addVariables:in:

PracticaTest>>testVariableBinding

PracticaTest(TestCase)>>performTest

[ 
self setUp.
self performTest ] in PracticaTest(TestCase)>>runCase

BlockClosure>>ensure:

PracticaTest(TestCase)>>runCase

[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:

BlockClosure>>on:do:

TestResult>>runCase:

PracticaTest(TestCase)>>run:

[ self run: result ] in PracticaTest(TestCase)>>run

BlockClosure>>ensure:

PracticaTest(TestCase)>>run

PracticaTest class(TestCase class)>>run:

PackageTreeNautilusUI(NautilusUI)>>runTestForAMethodWithAnHalt:

[ self runTestForAMethodWithAnHalt: aMethod ] in [ :e | 
aBoolean
	ifTrue: [ 
		[ self runTestForAMethodWithAnHalt: aMethod ] fork.
		shouldAnnounce := false.
		TestAsserter classForTestResult new ]
	ifFalse: [ 
		TestAsserter classForTestResult new
			addFailure: (testClass selector: testMethod selector);
			yourself ] ] in [ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority:

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:39:14.08756 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#b)
		aBlock: 	[ #b binding ]
		newBlock: 	nil
		lastVariable: 	#b

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1535625

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(3.0@19.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(219938816) a ...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendKeyboardEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(707@500.0) corner: (723@516.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(429129728)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(699@492) mouseOver nil nil]

		targetOffset: 	(94.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1471921 699 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addVariables:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:39:38.55856 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1560218

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-17.0@ -4.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(687@477.0) corner: (703@493.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@477) mouseOver CTRL nil nil]

		targetOffset: 	(93.0@85.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1559812 687 477 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(687@477.0) corner: (703@493.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@477) mouseOver CTRL nil nil]

		targetOffset: 	(93.0@85.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1559812 687 477 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:40:34.50856 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog ad...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1616171

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-50.0@ -3.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(654@478.0) corner: (670@494.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(654@478) mouseOver nil nil]

		targetOffset: 	(107.0@78.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1615593 654 478 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(654@478.0) corner: (670@494.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(654@478) mouseOver nil nil]

		targetOffset: 	(107.0@78.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1615593 654 478 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:41:28.10456 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1669765

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-22.0@11.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(682@492.0) corner: (698@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(682@492) mouseOver CTRL nil nil]

		targetOffset: 	(109.0@97.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1668890 682 492 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(682@492.0) corner: (698@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(682@492) mouseOver CTRL nil nil]

		targetOffset: 	(109.0@97.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1668890 682 492 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for b

28 November 2018 3:42:41.93156 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #b

	Arguments and temporary variables: 

		aString: 	'No binding for b'

	Receiver's instance variables: 

#b



ByteSymbol(Symbol)>>binding

	Receiver: #b

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#b



[ #b binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(700.0@480.0) corner: (1140.0@647.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(700@480) corner: (1140@647)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 108)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	1743593

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-26.0@1.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(678@482.0) corner: (694@498.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@482) mouseOver nil nil]

		targetOffset: 	(183.0@92.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1742921 678 482 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(678@482.0) corner: (694@498.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@482) mouseOver nil nil]

		targetOffset: 	(183.0@92.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1742921 678 482 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #b binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

28 November 2018 3:48:52.54356 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		block: 	[ #b binding ]
		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog addV...etc...
		itsSelection: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
...etc...
		itsSelectionString: 	'|block prog|
block:= [#b binding].
prog := PROG new.
prog ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| block prog |
	block := [ #b binding ].
	prog := PROG new.
	prog
		...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 127)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [locked]  [other:  (kmDispatcher -> a KM...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 127)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	2114078

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-72.0@0.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@98)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@98)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|block prog|
block:= [#b binding].
prog := PROG new.
prog add...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(347340800) a ...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendKeyboardEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>handleEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(152@383.0) corner: (168@399.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a MorphTreeMorph(185860096)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(152@383) mouseOver nil nil]

		targetOffset: 	(207.0@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2113187 152 383 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for RETURN

28 November 2018 5:28:38.337913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #RETURN

	Arguments and temporary variables: 

		aString: 	'No binding for RETURN'

	Receiver's instance variables: 

#RETURN



ByteSymbol(Symbol)>>binding

	Receiver: #RETURN

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	a PROG
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	nil

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	2

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0 ...etc...
		itsSelection: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBi...etc...
		itsSelectionString: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit: {#n}
		do:
			{{#label1.
			[ #n changeBinding: 0...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 401)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 401)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(38010880)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(38010880)

	Receiver's instance variables: 

		timeStamp: 	4500734

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-134@ -52.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(90@331.0) corner: (106@347.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(90@331) mouseOver nil nil]

		targetOffset: 	(155@149)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 4500156 90 331 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(204734464) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(38010880)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(90@331.0) corner: (106@347.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(38010880)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(90@331) mouseOver nil nil]

		targetOffset: 	(155@149)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 4500156 90 331 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:38:00.451913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ #n changeBinding: 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	46

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ #n changeBinding: 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ #n changeBinding: 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chang...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n c...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ #n ...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 101)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 101)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5062875

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-10@6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@66)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@66)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ #n chan...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(519@588.0) corner: (535@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(519@588) mouseOver nil nil]

		targetOffset: 	(89@64.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5062281 519 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:38:27.508913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	38

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } in...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ 0 ]...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5089921

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-111@5.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(418@587.0) corner: (434@603.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(418@587) mouseOver nil nil]

		targetOffset: 	(353@40.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5089109 418 587 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>second

28 November 2018 5:39:42.471913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #second

	Receiver: [ 0 ]

	Arguments and temporary variables: 

		aMessage: 	second
		exception: 	MessageNotUnderstood: BlockClosure>>second
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	38

		numArgs: 	0





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(#label1 [ 0 ])
		aBlock: 	[ #label1 binding ]
		newBlock: 	nil
		lastLine: 	[ 0 ]
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

a PROG



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } in...etc...
		itsSelection: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [...etc...
		itsSelectionString: 	'|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog |
	prog := PROG new.
	^ prog
		addCode:
			{#label1.
			[ 0 ]...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 83)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5164890

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-148@ -1.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@50)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@50)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog|
prog := PROG new.
prog addCode:  { #label1 . [ 0 ] } i...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(381@581.0) corner: (397@597.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(381@581) mouseOver nil nil]

		targetOffset: 	(341@41.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5164406 381 581 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #second

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for n

28 November 2018 5:42:43.519913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #n

	Arguments and temporary variables: 

		aString: 	'No binding for n'

	Receiver's instance variables: 

#n



ByteSymbol(Symbol)>>binding

	Receiver: #n

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#n



[ #n binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #n binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #n binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode:...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #n binding ].
	prog
		addCode:...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 102)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5345937

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(181@49.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #n binding] .
prog addCode...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(702@622.0) corner: (718@638.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(702@622.0) corner: (718@638.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(710@631) mouseOver nil nil]

		targetOffset: 	(183.0@204.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5333218 710 631 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(702@622.0) corner: (718@638.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(702@622.0) corner: (718@638.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(710@631) mouseOver nil nil]

		targetOffset: 	(183.0@204.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5333218 710 631 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #n binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:06.691913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog add...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	prog
		add...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 107)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 107)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5369109

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-15@9.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
prog ad...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(514@591.0) corner: (530@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(514@591) mouseOver nil nil]

		targetOffset: 	(79.0@93.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5368703 514 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(514@591.0) corner: (530@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(514@591) mouseOver nil nil]

		targetOffset: 	(79.0@93.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5368703 514 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:20.373913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5382781

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-58@ -33.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(471@549.0) corner: (487@565.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(471@549) mouseOver nil nil]

		targetOffset: 	(57@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5382312 471 549 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(471@549.0) corner: (487@565.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(471@549) mouseOver nil nil]

		targetOffset: 	(57@74.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5382312 471 549 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 5:43:48.405913 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	5410843

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-21@9.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(508@591.0) corner: (524@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(508@591) mouseOver nil nil]

		targetOffset: 	(97@81.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5410187 508 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a SpecW...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(508@591.0) corner: (524@607.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(508@591) mouseOver nil nil]

		targetOffset: 	(97@81.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 5410187 508 591 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:25:25.510136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ #label1 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= prog...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] ....etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= ...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ #label1 binding ].
	b := prog
...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 111)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11507906

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-17@6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding] .
b:= pro...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(512@588.0) corner: (528@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(512@588) mouseOver nil nil]

		targetOffset: 	(78.0@87.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11506796 512 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(512@588.0) corner: (528@604.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(512@588) mouseOver nil nil]

		targetOffset: 	(78.0@87.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11506796 512 588 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding ] in UndefinedObject>>DoIt

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:31:34.521136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 484)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 484)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11876937

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-37@ -77.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(492@505.0) corner: (508@521.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(492@505) mouseOver CTRL nil nil]

		targetOffset: 	(61@203)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11876453 492 505 0 2 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:31:59.654136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11902062

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-47@ -23.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(482@559.0) corner: (498@575.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(482@559) mouseOver nil nil]

		targetOffset: 	(82@201)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11901578 482 559 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:33:27.979136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	11990390

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-33@ -90.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(496@492.0) corner: (512@508.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(496@492) mouseOver nil nil]

		targetOffset: 	(59@200)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 11989984 496 492 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:34:31.117136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12053531

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-18@ -58.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(511@524.0) corner: (527@540.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(511@524) mouseOver nil nil]

		targetOffset: 	(81@205)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12052968 511 524 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: Array>>bindTo:in:

28 November 2018 7:35:44.371136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>doesNotUnderstand: #bindTo:in:

	Receiver: an Array(#label1 [ #n changeBinding: 0 ])

	Arguments and temporary variables: 

		aMessage: 	bindTo: [ 
codeLine value.
#RETURN binding value: nil ] in: [ 
#label...etc...
		exception: 	MessageNotUnderstood: Array>>bindTo:in:
		resumeValue: 	nil

	Receiver's instance variables: 

an Array(#label1 [ #n changeBinding: 0 ])



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		lableLine: 	an Array(#label1 [ #n changeBinding: 0 ])

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a ScrollBar(525074432) a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 483)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12126781

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-48@34.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@210)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@210)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Syste...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(481@573.0) corner: (497@589.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(481@573) mouseOver nil nil]

		targetOffset: 	(352@134)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12121593 481 573 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>doesNotUnderstand: #bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

SubscriptOutOfBounds: 0

28 November 2018 7:45:08.248136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>errorSubscriptBounds:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(Object)>>at:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(SequenceableCollection)>>last

	Receiver: #()

	Arguments and temporary variables: 



	Receiver's instance variables: 

#()



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	nil
		lableLine: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ...etc...
		lastLine: 	an Array(#label1 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: n...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 207)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 207)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12690671

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(149@116.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(670@689.0) corner: (686@705.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(670@689.0) corner: (686@705.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	a MouseClickState[#firstClickUp]

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(678@698) mouseOver nil nil]

		targetOffset: 	(149@116)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 12689484 678 698 0 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

Array(Object)>>errorSubscriptBounds:

Array(Object)>>at:

Array(SequenceableCollection)>>last

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:45:34.851136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ #label1 binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

#label7



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ #label1 binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		lableLine: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0 ...etc...
		itsSelection: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBi...etc...
		itsSelectionString: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit: {#n}
		do:
			{{#label1.
			[ #n changeBinding: 0...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(38010880)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 399)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(38010880)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@162)

		owner: 	a TransformMorph(321912832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@162)

		color: 	Color black

		extension: 	a MorphExtension (98828288) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(408420352)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(408420352)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(220.0@382.0) corner: (660.0@549.0)

		owner: 	a SystemWindow(204734464)

		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(321912832))

		fullBounds: 	(220@382) corner: (660@549)

		color: 	Color white

		extension: 	a MorphExtension (16777216) [other:  (kmDispatcher -> a KMDispatcher...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(448266240)

		scroller: 	a TransformMorph(321912832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(363593728)

		textMorph: 	a TextMorphForEditView(38010880)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 399)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(408420352)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(408420352)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...

		morph: 	a PluggableTextMorph(408420352)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(408420352)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ #label1 binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label1

28 November 2018 7:45:50.380136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label1

	Arguments and temporary variables: 

		aString: 	'No binding for label1'

	Receiver's instance variables: 

#label1



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label1



[ 
#label1 binding.
#label2 binding ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding.
#label2 binding ]

	Receiver's instance variables: 

#label2



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label1 binding.
#label2 binding ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 bi...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding.
	#label2 bi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 205)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 205)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12732796

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-3@ -6.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding. #label2 b...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ 
#label1 binding.
#label2 binding ] in UndefinedObject>>DoIt

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label2

28 November 2018 7:49:06.475136 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label2

	Arguments and temporary variables: 

		aString: 	'No binding for label2'

	Receiver's instance variables: 

#label2



ByteSymbol(Symbol)>>binding

	Receiver: #label2

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label2



[ 
#label1 binding traceCr.
#label2 binding traceCr ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]

	Receiver's instance variables: 

#label1



[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
#label1 binding traceCr.
#label2 binding traceCr ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	i...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #l...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding tr...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label1 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 167)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(525.0@581.0) corner: (965.0@748.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(525@581) corner: (965@748)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 167)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	12928906

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-54@ -40.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@114)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@114)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [ #label1 binding traceCr. #...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ 
#label1 binding traceCr.
#label2 binding traceCr ] in UndefinedObject>>DoIt

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:29:27.780737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: n...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		lableLine: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 218)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 218)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	869890

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-34.0@ -8.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(817@27.0) corner: (833@43.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(257425408)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(817@27) mouseOver nil nil]

		targetOffset: 	(125.0@139.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 868609 817 27 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(592707584) a ...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(817@27.0) corner: (833@43.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(257425408)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(817@27) mouseOver nil nil]

		targetOffset: 	(125.0@139.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 868609 817 27 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(817@27.0) corner: (833@43.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(257425408)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(817@27) mouseOver nil nil]

		targetOffset: 	(125.0@139.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 868609 817 27 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:33:46.577737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil...etc...
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		lableLine binding value ...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		lableLine: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
lableLine
	bindTo: [ 
		codeLine value.
		#RETURN binding value: n...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		lableLine: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 218)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 218)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1128718

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(2.0@12.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(853@47.0) corner: (869@63.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(281542656)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(845@39) mouseOver nil nil]

		targetOffset: 	(176.0@121.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1127406 845 39 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a TickingSpecWindow(1069547520) a...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(853@47.0) corner: (869@63.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(281542656)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(845@39) mouseOver nil nil]

		targetOffset: 	(176.0@121.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1127406 845 39 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(853@47.0) corner: (869@63.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a NewList(281542656)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(845@39) mouseOver nil nil]

		targetOffset: 	(176.0@121.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1127406 845 39 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Error: No binding for label2

29 November 2018 1:39:54.865737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Object)>>error:

	Receiver: #label2

	Arguments and temporary variables: 

		aString: 	'No binding for label2'

	Receiver's instance variables: 

#label2



ByteSymbol(Symbol)>>binding

	Receiver: #label2

	Arguments and temporary variables: 

		context: 	nil

	Receiver's instance variables: 

#label2



[ 
#label2 binding traceCr.
#label3 binding traceCr ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: a...etc...

	Receiver's instance variables: 

nil



Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: a...etc...

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1497093

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-10.0@9.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

ByteSymbol(Object)>>error:

ByteSymbol(Symbol)>>binding

[ 
#label2 binding traceCr.
#label3 binding traceCr ] in UndefinedObject>>DoIt

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:40:40.861737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1543109

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-25.0@ -14.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(826@21.0) corner: (842@37.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(826@21) mouseOver nil nil]

		targetOffset: 	(181.0@124.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1542625 826 21 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(826@21.0) corner: (842@37.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(826@21) mouseOver nil nil]

		targetOffset: 	(181.0@124.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1542625 826 21 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(826@21.0) corner: (842@37.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(826@21) mouseOver nil nil]

		targetOffset: 	(181.0@124.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1542625 826 21 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:41:14.101737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1576343

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(55.0@124.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(898@150.0) corner: (914@166.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(898@150.0) corner: (914@166.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(906@159) mouseOver nil nil]

		targetOffset: 	(172.0@122.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1572828 906 159 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(898@150.0) corner: (914@166.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(898@150.0) corner: (914@166.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(906@159) mouseOver nil nil]

		targetOffset: 	(172.0@122.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1572828 906 159 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(898@150.0) corner: (914@166.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(898@150.0) corner: (914@166.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(906@159) mouseOver nil nil]

		targetOffset: 	(172.0@122.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1572828 906 159 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:42:38.021737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1660250

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(58.0@126.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(901@152.0) corner: (917@168.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(901@152.0) corner: (917@168.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(909@161) mouseOver nil nil]

		targetOffset: 	(195.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1656406 909 161 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(901@152.0) corner: (917@168.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(901@152.0) corner: (917@168.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(909@161) mouseOver nil nil]

		targetOffset: 	(195.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1656406 909 161 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(901@152.0) corner: (917@168.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(901@152.0) corner: (917@168.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(909@161) mouseOver nil nil]

		targetOffset: 	(195.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1656406 909 161 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:43:42.138737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1724375

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-164.0@ -23.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(687@12.0) corner: (703@28.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@12) mouseOver nil nil]

		targetOffset: 	(209.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1723625 687 12 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(687@12.0) corner: (703@28.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@12) mouseOver nil nil]

		targetOffset: 	(209.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1723625 687 12 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(687@12.0) corner: (703@28.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(687@12) mouseOver nil nil]

		targetOffset: 	(209.0@123.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1723625 687 12 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:45:17.932737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1820171

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-30.0@ -36.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(821@ -1.0) corner: (837@15.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(821@ -1) mouseOver nil nil]

		targetOffset: 	(126.0@137.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1819750 821 -1 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(821@ -1.0) corner: (837@15.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(821@ -1) mouseOver nil nil]

		targetOffset: 	(126.0@137.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1819750 821 -1 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(821@ -1.0) corner: (837@15.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(821@ -1) mouseOver nil nil]

		targetOffset: 	(126.0@137.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1819750 821 -1 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 1:47:38.993737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: a...etc...
		lastLine: 	an Array(#label2 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label2 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label3 [ 'adfa' ])
		codeLine: 	[ 'adfa' ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 

		prog: 	a PROG
		b: 	[ 
#label2 binding traceCr.
#label3 binding traceCr ]

	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. #...etc...
		itsSelection: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding t...etc...
		itsSelectionString: 	'|prog b|
prog := PROG new.
b :=  [  #label2 binding traceC...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	| prog b |
	prog := PROG new.
	b := [ 
	#label2 binding traceCr.
	#l...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(847.0@34.0) corner: (1287.0@201.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(847@34) corner: (1287@201)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 211)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#ScrollPan...etc...

		morph: 	a PluggableTextMorph(485228544)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(485228544)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...

		morph: 	a TextMorphForEditView(241434624)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleKeystroke:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





KeyboardEvent>>sentTo:

	Receiver: [keystroke '<Ctrl-p>']

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(241434624)

	Receiver's instance variables: 

		timeStamp: 	1961218

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#keystroke

		buttons: 	16

		position: 	(-23.0@ -20.0)

		handler: 	nil

		wasHandled: 	true

		keyValue: 	16

		charCode: 	16

		scanCode: 	80





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>handleFocusEvent:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@130)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@130)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '|prog b|
prog := PROG new.
b :=  [  #label2 binding traceCr. ...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(828@15.0) corner: (844@31.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(828@15) mouseOver nil nil]

		targetOffset: 	(144.0@132.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1960734 828 15 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





BlockClosure>>on:do:

	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	HandMorph>>sendFocusEvent:to:clear:

		startpc: 	67

		numArgs: 	0





WorldMorph(PasteUpMorph)>>becomeActiveDuring:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1536@801)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(365166592) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1536@801)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendFocusEvent:to:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		bounds: 	(828@15.0) corner: (844@31.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(828@15) mouseOver nil nil]

		targetOffset: 	(144.0@132.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1960734 828 15 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(241434624)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(828@15.0) corner: (844@31.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(241434624)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(828@15) mouseOver nil nil]

		targetOffset: 	(144.0@132.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	nil

		temporaryCursorOffset: 	nil

		hardwareCursor: 	nil

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 1960734 828 15 0 0 0 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	2







--- The full stack ---

PROG>>addCode:in:

PROG>>addCode:in:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:49:41.348737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext>>receiver

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext>>receiver

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:50:19.067737 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext>>receiver

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext>>receiver

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:55:29.167126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



SmallInteger(Magnitude)>>min:

	Receiver: 25

	Arguments and temporary variables: 

		aMagnitude: 	25

	Receiver's instance variables: 

25



Point>>min:

	Receiver: (25@ -28171)

	Arguments and temporary variables: 

		aPoint: 	(25@215)

	Receiver's instance variables: 

		x: 	25

		y: 	-28171





[ :p | 
topLeft := topLeft min: p.
bottomRight := bottomRight max: p ] in Rectangle class>>encompassing:

	Receiver: Rectangle

	Arguments and temporary variables: 

		listOfPoints: 	{(25@ -28171). (25@215). (338@215). (338@ -28171)}
		topLeft: 	(25@ -28171)
		bottomRight: 	(25@ -28171)
		p: 	(25@215)

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(size 106)

		format: 	20614

		layout: 	a FixedLayout

		instanceVariables: 	#('origin' 'corner')

		organization: 	a ClassOrganization

		subclasses: 	{CharacterBlock}

		name: 	#Rectangle

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Kernel-BasicObjects'

		traitComposition: 	{}

		localSelectors: 	nil





Array(SequenceableCollection)>>allButFirstDo:

	Receiver: {(25@ -28171). (25@215). (338@215). (338@ -28171)}

	Arguments and temporary variables: 

		block: 	[ :p | 
topLeft := topLeft min: p.
bottomRight := bottomRight max: p ]
		index: 	2

	Receiver's instance variables: 

{(25@ -28171). (25@215). (338@215). (338@ -28171)}



Rectangle class>>encompassing:

	Receiver: Rectangle

	Arguments and temporary variables: 

		topLeft: 	(25@ -28171)
		bottomRight: 	(25@ -28171)
		listOfPoints: 	{(25@ -28171). (25@215). (338@215). (338@ -28171)}

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(size 106)

		format: 	20614

		layout: 	a FixedLayout

		instanceVariables: 	#('origin' 'corner')

		organization: 	a ClassOrganization

		subclasses: 	{CharacterBlock}

		name: 	#Rectangle

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Kernel-BasicObjects'

		traitComposition: 	{}

		localSelectors: 	nil





MorphicTransform(DisplayTransform)>>localBoundsToGlobal:

	Receiver: a MorphicTransform(angle = 0.0; scale = 1.0; offset = (-25@28171))

	Arguments and temporary variables: 

		aRectangle: 	(0@0) corner: (313@28386)

	Receiver's instance variables: 

		offset: 	(-25@28171)

		angle: 	0.0

		scale: 	1.0





TransformMorph>>invalidRect:from:

	Receiver: a TransformMorph(639107072)

	Arguments and temporary variables: 

		damageRect: 	(0@0) corner: (313@28386)
		aMorph: 	a TextMorphForEditView(625999872)

	Receiver's instance variables: 

		bounds: 	(22@29) corner: (341@194)

		owner: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		submorphs: 	an Array(a TextMorphForEditView(625999872))

		fullBounds: 	nil

		color: 	Color transparent

		extension: 	a MorphExtension (661127168) [other:  (kmDispatcher -> a KMDispatche...etc...

		transform: 	a MorphicTransform(angle = 0.0; scale = 1.0; offset = (-25@28171))

		smoothing: 	1

		localBounds: 	(0@0) corner: (313@28386)





TextMorphForEditView(Morph)>>invalidRect:from:

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 

		aRectangle: 	(0@0) corner: (313@28386)
		aMorph: 	a TextMorphForEditView(625999872)
		damageRect: 	(0@0) corner: (313@28386)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(Morph)>>invalidRect:

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 

		damageRect: 	(0@0) corner: (313@28386)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView>>refreshExtraSelection

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 

		fullRefreshNeeded: 	true

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>vScrollBarValue:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		scrollValue: 	0.9987250318742031

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





ScrollBar(Slider)>>setValue:

	Receiver: a ScrollBar(965738496)

	Arguments and temporary variables: 

		newValue: 	0.9987250318742031

	Receiver's instance variables: 

		bounds: 	(341.0@29.0) corner: (354.0@194.0)

		owner: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		submorphs: 	an Array(a BorderedMorph(395313152) a Morph(246939648) a BorderedMor...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.96 g: 0.96 b: 0.96 alpha: 1.0)

		extension: 	a MorphExtension (109576192) [eventHandler = a MorphicEventHandler] ...etc...

		borderWidth: 	0

		borderColor: 	Color black

		model: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		open: 	false

		accessor: 	#vScrollBarValue

		slider: 	a BorderedMorph(395313152)

		value: 	0.9987250318742031

		setValueSelector: 	nil

		sliderShadow: 	a BorderedMorph(418906112)

		sliderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...

		descending: 	false

		upButton: 	a BorderedMorph(959447040)

		downButton: 	a BorderedMorph(641990656)

		pagingArea: 	a Morph(246939648)

		scrollDelta: 	0.00042498937526561835

		pageDelta: 	0.005418614534636634

		interval: 	0.005810268328755546

		timeOfMouseDown: 	nil

		timeOfLastScroll: 	nil

		nextPageDirection: 	nil

		currentScrollDelay: 	nil





ScrollBar>>setValue:

	Receiver: a ScrollBar(965738496)

	Arguments and temporary variables: 

		newValue: 	0.9988312792180195

	Receiver's instance variables: 

		bounds: 	(341.0@29.0) corner: (354.0@194.0)

		owner: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		submorphs: 	an Array(a BorderedMorph(395313152) a Morph(246939648) a BorderedMor...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.96 g: 0.96 b: 0.96 alpha: 1.0)

		extension: 	a MorphExtension (109576192) [eventHandler = a MorphicEventHandler] ...etc...

		borderWidth: 	0

		borderColor: 	Color black

		model: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		open: 	false

		accessor: 	#vScrollBarValue

		slider: 	a BorderedMorph(395313152)

		value: 	0.9987250318742031

		setValueSelector: 	nil

		sliderShadow: 	a BorderedMorph(418906112)

		sliderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...

		descending: 	false

		upButton: 	a BorderedMorph(959447040)

		downButton: 	a BorderedMorph(641990656)

		pagingArea: 	a Morph(246939648)

		scrollDelta: 	0.00042498937526561835

		pageDelta: 	0.005418614534636634

		interval: 	0.005810268328755546

		timeOfMouseDown: 	nil

		timeOfLastScroll: 	nil

		nextPageDirection: 	nil

		currentScrollDelay: 	nil





ThreadSafeTranscriptPluggableTextMorph(ScrollPane)>>vSetScrollDelta

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		range: 	28236
		delta: 	12

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





ThreadSafeTranscriptPluggableTextMorph(ScrollPane)>>setScrollDeltas

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





TextMorphForEditView>>updateFromParagraph

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 

		editBlock: 	[ result := editBlock value ]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@28386)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@28386)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '
''pene''
''pene''
''pene''
''pene''
''pene''
''pene''
''pene...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		result: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)
		editBlock: 	[ self appendEntry ]

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ super update: aSymbol ] in ThreadSafeTranscriptPluggableTextMorph>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





BlockClosure>>ensure:

	Receiver: [ super update: aSymbol ]

	Arguments and temporary variables: 

		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	ThreadSafeTranscriptPluggableTextMorph>>update:

		startpc: 	28

		numArgs: 	0





[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ super update: aSymbol ]
		activeProcess: 	a Process in SmallInteger(Magnitude)>>min:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in SmallInteger(Magnitude)>>min:





[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ super update: aSymbol ]
		activeProcess: 	a Process in SmallInteger(Magnitude)>>min:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in SmallInteger(Magnitude)>>min:





ThreadSafeTranscriptPluggableTextMorph>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ :aDependent | aDependent update: aParameter ] in ThreadSafeTranscript(Object)>>changed:

	Receiver: Transcript

	Arguments and temporary variables: 

		aParameter: 	#appendEntry
		aDependent: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





DependentsArray>>do:

	Receiver: a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPluggableTextMorph(923271...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)
		i: 	2

	Receiver's instance variables: 

a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPluggableTextMorph(923271...etc...



ThreadSafeTranscript(Object)>>changed:

	Receiver: Transcript

	Arguments and temporary variables: 

		aParameter: 	#appendEntry

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





[ 
self changed: #appendEntry.
stream resetContents ] in ThreadSafeTranscript>>endEntry

	Receiver: Transcript

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





BlockClosure>>ensure:

	Receiver: [ 
self changed: #appendEntry.
stream resetContents ]

	Arguments and temporary variables: 

		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	ThreadSafeTranscript>>endEntry

		startpc: 	34

		numArgs: 	0





[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ 
self changed: #appendEntry.
stream resetContents ]
		activeProcess: 	a Process in SmallInteger(Magnitude)>>min:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in SmallInteger(Magnitude)>>min:





[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ 
self changed: #appendEntry.
stream resetContents ]
		activeProcess: 	a Process in SmallInteger(Magnitude)>>min:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in SmallInteger(Magnitude)>>min:





ThreadSafeTranscript>>endEntry

	Receiver: Transcript

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex







--- The full stack ---

SmallInteger(Magnitude)>>min:

Point>>min:

[ :p | 
topLeft := topLeft min: p.
bottomRight := bottomRight max: p ] in Rectangle class>>encompassing:

Array(SequenceableCollection)>>allButFirstDo:

Rectangle class>>encompassing:

MorphicTransform(DisplayTransform)>>localBoundsToGlobal:

TransformMorph>>invalidRect:from:

TextMorphForEditView(Morph)>>invalidRect:from:

TextMorphForEditView(Morph)>>invalidRect:

TextMorphForEditView>>refreshExtraSelection

TextMorphForEditView>>selectionChanged

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>vScrollBarValue:

ScrollBar(Slider)>>setValue:

ScrollBar>>setValue:

ThreadSafeTranscriptPluggableTextMorph(ScrollPane)>>vSetScrollDelta

ThreadSafeTranscriptPluggableTextMorph(ScrollPane)>>setScrollDeltas

TextMorphForEditView>>updateFromParagraph

TextMorphForEditView(TextMorph)>>handleEdit:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

[ super update: aSymbol ] in ThreadSafeTranscriptPluggableTextMorph>>update:

BlockClosure>>ensure:

[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscriptPluggableTextMorph>>update:

[ :aDependent | aDependent update: aParameter ] in ThreadSafeTranscript(Object)>>changed:

DependentsArray>>do:

ThreadSafeTranscript(Object)>>changed:

[ 
self changed: #appendEntry.
stream resetContents ] in ThreadSafeTranscript>>endEntry

BlockClosure>>ensure:

[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscript>>endEntry

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

ThreadSafeTranscript>>show:

ByteString(Object)>>traceCr:

ByteString(Object)>>traceCr

[ 
'pene' traceCr.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:55:31.202126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ super drawSubmorphsOn: aCanvas ]
		activeProcess: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuall...etc...

	Receiver's instance variables: 

		semaphore: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue :=...etc...

		owner: 	a Process in SmallInteger(Magnitude)>>min:





ThreadSafeTranscriptPluggableTextMorph>>drawSubmorphsOn:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	(21@28) corner: (355@195)

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	(21@28) corner: (355@195)

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





FormCanvas>>roundCornersOf:in:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)
		bounds: 	(21.0@28.0) corner: (355.0@195.0)
		aBlock: 	[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@1.0) corner: (359.0@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





FormCanvas(Canvas)>>roundCornersOf:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)
		aBlock: 	[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@1.0) corner: (359.0@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





[ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	(21@28) corner: (355@195)

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





BlockClosure>>on:do:

	Receiver: [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so tha...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :err | 
self setProperty: #errorOnDraw toValue: true.
self set...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

		startpc: 	142

		numArgs: 	0





ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	(21@28) corner: (355@195)

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(12405 to: 12404)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





FormCanvas(Canvas)>>fullDraw:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		anObject: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@1.0) corner: (359.0@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





FormCanvas(Canvas)>>fullDrawMorph:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@1.0) corner: (359.0@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SystemWindow(Morph)>>drawSubmorphsOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		drawBlock: 	[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ]
		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		m: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





Array(SequenceableCollection)>>reverseDo:

	Receiver: an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a WindowEdgeGripMorph(2909798...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :m | canvas fullDrawMorph: m ]
		index: 	1

	Receiver's instance variables: 

an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a WindowEdgeGripMorph(2909798...etc...



[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SystemWindow(Morph)>>drawSubmorphsOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		drawBlock: 	[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ]
		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





FormCanvas>>clipBy:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aRectangle: 	(22@1.0) corner: (359.0@199.0)
		aBlock: 	[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ]

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@0) corner: (360@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





SystemWindow(Morph)>>drawSubmorphsOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		drawBlock: 	[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ]

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SystemWindow(Morph)>>fullDrawOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





FormCanvas>>roundCornersOf:in:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a SystemWindow(92012544)
		bounds: 	(16.0@0.0) corner: (360.0@200.0)
		aBlock: 	[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@0) corner: (360@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





FormCanvas(Canvas)>>roundCornersOf:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a SystemWindow(92012544)
		aBlock: 	[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@0) corner: (360@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





[ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SystemWindow(Morph)>>fullDrawOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





BlockClosure>>on:do:

	Receiver: [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so tha...etc...

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :err | 
self setProperty: #errorOnDraw toValue: true.
self set...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	SystemWindow(Morph)>>fullDrawOn:

		startpc: 	142

		numArgs: 	0





SystemWindow(Morph)>>fullDrawOn:

	Receiver: a SystemWindow(92012544)

	Arguments and temporary variables: 

		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

	Receiver's instance variables: 

		bounds: 	(16.0@0.0) corner: (360.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168) a Windo...etc...

		fullBounds: 	(16@0) corner: (360@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (212860928) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	Transcript

		open: 	false

		accessor: 	nil

		labelString: 	'Transcript'

		stripes: 	an Array(a Morph(687341568) a Morph(711196672))

		label: 	a LabelMorph(348389376)'Transcript'

		closeBox: 	a MultistateButtonMorph(1036517376)

		collapseBox: 	a MultistateButtonMorph(546570240)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a ThreadSafeTranscriptPluggableTextMorph(923271168))

		collapsedFrame: 	(-10.0@ -10.0) corner: (204.0@17.0)

		fullFrame: 	(16.0@0.0) corner: (360.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(295174144)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(762314752)

		expandBox: 	a MultistateButtonMorph(771751936)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





FormCanvas(Canvas)>>fullDraw:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		anObject: 	a SystemWindow(92012544)

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@0) corner: (360@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





FormCanvas(Canvas)>>fullDrawMorph:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a SystemWindow(92012544)

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(22@0) corner: (360@199.0)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:

	Receiver: a WorldState

	Arguments and temporary variables: 

		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		rectList: 	{(22@0) corner: (1402@648). (61@188) corner: (64@195). (61@188) corne...etc...
		validList: 	an OrderedCollection()
		dirtyRect: 	(22@0) corner: (1402@648)
		mm: 	an ImageMorph(308281344)
		remnants: 	an OrderedCollection((818.0@0) corner: (819.0@20.0) (1269.0@0) corner...etc...
		r: 	(22@0) corner: (1402@648)
		rect: 	(22@0) corner: (360@199.0)
		i: 	11
		c: 	a FormCanvas on: DisplayScreen(1520x785x32)
		remnantIntersects: 	an OrderedCollection((360.0@0) corner: (368.0@20.0) (360.0@2...etc...
		rectToFill: 	(22@0) corner: (360@199.0)
		n: 	10
		morphs: 	an OrderedCollection(a SpecWindow(848035840) a SystemWindow(825753600) ...etc...
		rects: 	an OrderedCollection((388@20) corner: (1402@648) (368@0) corner: (818@20...etc...

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





Rectangle>>allAreasOutsideList:startingAt:do:

	Receiver: (22@0) corner: (1402@648)

	Arguments and temporary variables: 

		aCollection: 	an OrderedCollection()
		startIndex: 	1
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...
		yOrigin: 	nil
		yCorner: 	nil
		aRectangle: 	nil
		index: 	1
		rr: 	nil

	Receiver's instance variables: 

		origin: 	(22@0)

		corner: 	(1402@648)





Rectangle>>allAreasOutsideList:do:

	Receiver: (22@0) corner: (1402@648)

	Arguments and temporary variables: 

		aCollection: 	an OrderedCollection()
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...

	Receiver's instance variables: 

		origin: 	(22@0)

		corner: 	(1402@648)





drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:

	Receiver: a WorldState

	Arguments and temporary variables: 

		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		rectList: 	{(22@0) corner: (1402@648). (61@188) corner: (64@195). (61@188) corne...etc...
		validList: 	an OrderedCollection()
		n: 	10
		morphs: 	an OrderedCollection(a SpecWindow(848035840) a SystemWindow(825753600) ...etc...
		rects: 	an OrderedCollection((388@20) corner: (1402@648) (368@0) corner: (818@20...etc...
		dirtyRect: 	(22@0) corner: (1402@648)

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





Array(SequenceableCollection)>>do:

	Receiver: {(22@0) corner: (1402@648). (61@188) corner: (64@195). (61@188) corner: (64@195). (61@188)...etc...

	Arguments and temporary variables: 

		aBlock: 	drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw...etc...
		index: 	1

	Receiver's instance variables: 

{(22@0) corner: (1402@648). (61@188) corner: (64@195). (61@188) corner: (64@195). (61@188)...etc...



WorldState>>drawWorld:submorphs:invalidAreasOn:

	Receiver: a WorldState

	Arguments and temporary variables: 

		n: 	10
		morphs: 	an OrderedCollection(a SpecWindow(848035840) a SystemWindow(825753600) ...etc...
		rects: 	an OrderedCollection((388@20) corner: (1402@648) (368@0) corner: (818@20...etc...
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1520x785x32)
		rectList: 	{(22@0) corner: (1402@648). (61@188) corner: (64@195). (61@188) corne...etc...
		validList: 	an OrderedCollection()

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:

	Receiver: a WorldState

	Arguments and temporary variables: 

		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...
		deferredUpdateMode: 	true
		allDamage: 	nil
		handsToDraw: 	nil
		worldDamageRects: 	nil
		handDamageRects: 	nil

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





FormCanvas>>roundCornersOf:in:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a WorldMorph(511705088) [world]
		bounds: 	(0@0) corner: (1520@785)
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(0@0) corner: (1520@785)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





FormCanvas(Canvas)>>roundCornersOf:during:

	Receiver: a FormCanvas on: DisplayScreen(1520x785x32)

	Arguments and temporary variables: 

		aMorph: 	a WorldMorph(511705088) [world]
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...

	Receiver's instance variables: 

		origin: 	(0@0)

		clipRect: 	(0@0) corner: (1520@785)

		form: 	DisplayScreen(1520x785x32)

		port: 	a GrafPort





WorldState>>displayWorld:submorphs:

	Receiver: a WorldState

	Arguments and temporary variables: 

		allDamage: 	nil
		handsToDraw: 	nil
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...
		deferredUpdateMode: 	true

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





WorldMorph>>displayWorld

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(848035840) a SystemW...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





[ aWorld displayWorld ] in WorldState>>displayWorldSafely:

	Receiver: a WorldState

	Arguments and temporary variables: 

		aWorld: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(1012137984))(a DropLis...etc...

		lastStepTime: 	51939

		lastStepMessage: 	nil

		lastCycleTime: 	51788

		alarms: 	a Heap()

		lastAlarmTime: 	51939

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





BlockClosure>>on:do:

	Receiver: [ aWorld displayWorld ]

	Arguments and temporary variables: 

		exception: 	Error
		handlerAction: 	[ :ex | errorHandlerBlock cull: ex description cull: ex receiver...etc...
		handlerActive: 	true

	Receiver's instance variables: 

		outerContext: 	WorldState>>displayWorldSafely:

		startpc: 	82

		numArgs: 	0







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscriptPluggableTextMorph>>drawSubmorphsOn:

[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

FormCanvas>>roundCornersOf:in:during:

FormCanvas(Canvas)>>roundCornersOf:during:

[ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

BlockClosure>>on:do:

ThreadSafeTranscriptPluggableTextMorph(Morph)>>fullDrawOn:

FormCanvas(Canvas)>>fullDraw:

FormCanvas(Canvas)>>fullDrawMorph:

[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SystemWindow(Morph)>>drawSubmorphsOn:

Array(SequenceableCollection)>>reverseDo:

[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SystemWindow(Morph)>>drawSubmorphsOn:

FormCanvas>>clipBy:during:

SystemWindow(Morph)>>drawSubmorphsOn:

[ 
(aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SystemWindow(Morph)>>fullDrawOn:

FormCanvas>>roundCornersOf:in:during:

FormCanvas(Canvas)>>roundCornersOf:during:

[ 
"Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].
(self hasRolloverBorder and: [ (aCanvas seesNothingOutside: self bounds) not ])
	ifTrue: [ self drawRolloverBorderOn: aCanvas ].	"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ 
		(aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SystemWindow(Morph)>>fullDrawOn:

BlockClosure>>on:do:

SystemWindow(Morph)>>fullDrawOn:

FormCanvas(Canvas)>>fullDraw:

FormCanvas(Canvas)>>fullDrawMorph:

[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:

Rectangle>>allAreasOutsideList:startingAt:do:

Rectangle>>allAreasOutsideList:do:

drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:

Array(SequenceableCollection)>>do:

WorldState>>drawWorld:submorphs:invalidAreasOn:

[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:

FormCanvas>>roundCornersOf:in:during:

FormCanvas(Canvas)>>roundCornersOf:during:

WorldState>>displayWorld:submorphs:

WorldMorph>>displayWorld

[ aWorld displayWorld ] in WorldState>>displayWorldSafely:

BlockClosure>>on:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

BlockClosure>>ifError:

WorldState>>displayWorldSafely:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:13.307126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:24.225126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:24.492126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



WriteStream>>nextPut:

	Receiver: a WriteStream

	Arguments and temporary variables: 

		anObject: 	a WeakAnnouncementSubscription

	Receiver's instance variables: 

		collection: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil n...etc...

		position: 	0

		readLimit: 	0

		writeLimit: 	100





[ :each | 
(each handlesAnnouncement: anAnnouncement)
	ifTrue: [ s nextPut: each ] ] in [ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement: anAnnouncement)
			ifTrue: [ s nextPut: each ] ] ] in SubscriptionRegistry>>subscriptionsHandling:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		s: 	a WriteStream
		each: 	a WeakAnnouncementSubscription

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





IdentitySet(Set)>>do:

	Receiver: an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncementSubscription a WeakAnnounc...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :each | 
(each handlesAnnouncement: anAnnouncement)
	ifTrue: [ s next...etc...
		index: 	1
		each: 	a WeakAnnouncementSubscription

	Receiver's instance variables: 

		tally: 	11

		array: 	an Array(a WeakAnnouncementSubscription a WeakAnnouncementSubscription n...etc...





[ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement: anAnnouncement)
			ifTrue: [ s nextPut: each ] ] ] in SubscriptionRegistry>>subscriptionsHandling:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		s: 	a WriteStream

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





Array class(SequenceableCollection class)>>new:streamContents:

	Receiver: Array

	Arguments and temporary variables: 

		newSize: 	100
		blockWithArg: 	[ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement...etc...
		stream: 	a WriteStream

	Receiver's instance variables: 

		superclass: 	ArrayedCollection

		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...

		format: 	6402

		layout: 	a VariableLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}

		name: 	#Array

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Collections-Sequenceable'

		traitComposition: 	{}

		localSelectors: 	nil





Array class(SequenceableCollection class)>>streamContents:

	Receiver: Array

	Arguments and temporary variables: 

		blockWithArg: 	[ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement...etc...

	Receiver's instance variables: 

		superclass: 	ArrayedCollection

		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...

		format: 	6402

		layout: 	a VariableLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}

		name: 	#Array

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Collections-Sequenceable'

		traitComposition: 	{}

		localSelectors: 	nil





SubscriptionRegistry>>subscriptionsHandling:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement ] in SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		interestedSubscriptions: 	nil

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





[ aBlock value ] in SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ aBlock value ]
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ aBlock value ]

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		interestedSubscriptions: 	nil
		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore()





Announcer>>announce:

	Receiver: an Announcer

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		announcement: 	a MorphChanged

	Receiver's instance variables: 

		registry: 	a SubscriptionRegistry





EditorFindReplaceDialogWindow(Morph)>>changed:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		anAspect: 	#replaceEnabled

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





EditorFindReplaceDialogWindow>>update:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		aSymbol: 	#findReplaceSelection
		si: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection
		aDependent: 	an EditorFindReplaceDialogWindow(204210176)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





DependentsArray>>do:

	Receiver: a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	an EditorFindReplaceDialogWindow(204210176)
		i: 	1

	Receiver's instance variables: 

a DependentsArray(an EditorFindReplaceDialogWindow(204210176))



FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(90963968)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (17@290)

		owner: 	a TransformMorph(977272832)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (17@290)

		color: 	Color black

		extension: 	a MorphExtension (145752064) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'ByteSymbol(Symbol)>>changeBinding:'

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(296747008)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>hScrollBarValue:

	Receiver: a PluggableTextMorph(296747008)

	Arguments and temporary variables: 

		scrollValue: 	0.0

	Receiver's instance variables: 

		bounds: 	(41.0@0.0) corner: (77.0@40.0)

		owner: 	a PanelMorph(746586112)

		submorphs: 	an Array(a ScrollBar(324534272) a TransformMorph(977272832))

		fullBounds: 	(41@0) corner: (77@42)

		color: 	Color white

		extension: 	a MorphExtension (334495744) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color transparent

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(324534272)

		scroller: 	a TransformMorph(977272832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(144179200)

		textMorph: 	a TextMorphForEditView(90963968)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 0)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	false

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





ScrollBar(Slider)>>setValue:

	Receiver: a ScrollBar(144179200)

	Arguments and temporary variables: 

		newValue: 	0.0

	Receiver's instance variables: 

		bounds: 	(41.0@27.0) corner: (83.0@40.0)

		owner: 	nil

		submorphs: 	an Array(a BorderedMorph(687079424) a Morph(467402752) a BorderedMor...etc...

		fullBounds: 	(41.0@27.0) corner: (83.0@40.0)

		color: 	(Color r: 0.96 g: 0.96 b: 0.96 alpha: 1.0)

		extension: 	a MorphExtension (357302272) [eventHandler = a MorphicEventHandler] ...etc...

		borderWidth: 	0

		borderColor: 	Color black

		model: 	a PluggableTextMorph(296747008)

		open: 	false

		accessor: 	#hScrollBarValue

		slider: 	a BorderedMorph(687079424)

		value: 	0.0

		setValueSelector: 	nil

		sliderShadow: 	a BorderedMorph(716701696)

		sliderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...

		descending: 	false

		upButton: 	a BorderedMorph(1044381696)

		downButton: 	a BorderedMorph(798228480)

		pagingArea: 	a Morph(467402752)

		scrollDelta: 	0.02

		pageDelta: 	0.2

		interval: 	1.0

		timeOfMouseDown: 	nil

		timeOfLastScroll: 	nil

		nextPageDirection: 	nil

		currentScrollDelay: 	nil





ScrollBar>>setValue:

	Receiver: a ScrollBar(144179200)

	Arguments and temporary variables: 

		newValue: 	0

	Receiver's instance variables: 

		bounds: 	(41.0@27.0) corner: (83.0@40.0)

		owner: 	nil

		submorphs: 	an Array(a BorderedMorph(687079424) a Morph(467402752) a BorderedMor...etc...

		fullBounds: 	(41.0@27.0) corner: (83.0@40.0)

		color: 	(Color r: 0.96 g: 0.96 b: 0.96 alpha: 1.0)

		extension: 	a MorphExtension (357302272) [eventHandler = a MorphicEventHandler] ...etc...

		borderWidth: 	0

		borderColor: 	Color black

		model: 	a PluggableTextMorph(296747008)

		open: 	false

		accessor: 	#hScrollBarValue

		slider: 	a BorderedMorph(687079424)

		value: 	0.0

		setValueSelector: 	nil

		sliderShadow: 	a BorderedMorph(716701696)

		sliderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...

		descending: 	false

		upButton: 	a BorderedMorph(1044381696)

		downButton: 	a BorderedMorph(798228480)

		pagingArea: 	a Morph(467402752)

		scrollDelta: 	0.02

		pageDelta: 	0.2

		interval: 	1.0

		timeOfMouseDown: 	nil

		timeOfLastScroll: 	nil

		nextPageDirection: 	nil

		currentScrollDelay: 	nil





PluggableTextMorph(ScrollPane)>>hScrollValue:

	Receiver: a PluggableTextMorph(296747008)

	Arguments and temporary variables: 

		scrollValue: 	0

	Receiver's instance variables: 

		bounds: 	(41.0@0.0) corner: (77.0@40.0)

		owner: 	a PanelMorph(746586112)

		submorphs: 	an Array(a ScrollBar(324534272) a TransformMorph(977272832))

		fullBounds: 	(41@0) corner: (77@42)

		color: 	Color white

		extension: 	a MorphExtension (334495744) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color transparent

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(324534272)

		scroller: 	a TransformMorph(977272832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(144179200)

		textMorph: 	a TextMorphForEditView(90963968)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 0)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	false

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph(ScrollPane)>>scrollValue:

	Receiver: a PluggableTextMorph(296747008)

	Arguments and temporary variables: 

		aPoint: 	(0@0.0)

	Receiver's instance variables: 

		bounds: 	(41.0@0.0) corner: (77.0@40.0)

		owner: 	a PanelMorph(746586112)

		submorphs: 	an Array(a ScrollBar(324534272) a TransformMorph(977272832))

		fullBounds: 	(41@0) corner: (77@42)

		color: 	Color white

		extension: 	a MorphExtension (334495744) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color transparent

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(324534272)

		scroller: 	a TransformMorph(977272832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(144179200)

		textMorph: 	a TextMorphForEditView(90963968)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 0)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	false

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





[ :w | w scrollValue: aValue ] in MorphicTextAdapter>>setScrollValue:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aValue: 	(0@0.0)
		w: 	a PluggableTextMorph(296747008)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(296747008))

		model: 	a TextModel

		widget: 	a PluggableTextMorph(296747008)

		selector: 	nil





BlockClosure>>cull:

	Receiver: [ :w | w scrollValue: aValue ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(296747008)

	Receiver's instance variables: 

		outerContext: 	MorphicTextAdapter>>setScrollValue:

		startpc: 	27

		numArgs: 	1





PluggableTextMorph(ProtoObject)>>ifNotNil:

	Receiver: a PluggableTextMorph(296747008)

	Arguments and temporary variables: 

		ifNotNilBlock: 	[ :w | w scrollValue: aValue ]

	Receiver's instance variables: 

		bounds: 	(41.0@0.0) corner: (77.0@40.0)

		owner: 	a PanelMorph(746586112)

		submorphs: 	an Array(a ScrollBar(324534272) a TransformMorph(977272832))

		fullBounds: 	(41@0) corner: (77@42)

		color: 	Color white

		extension: 	a MorphExtension (334495744) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color transparent

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(324534272)

		scroller: 	a TransformMorph(977272832)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(144179200)

		textMorph: 	a TextMorphForEditView(90963968)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 0)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	false

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





MorphicTextAdapter(AbstractAdapter)>>widgetDo:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aBlock: 	[ :w | w scrollValue: aValue ]

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(296747008))

		model: 	a TextModel

		widget: 	a PluggableTextMorph(296747008)

		selector: 	nil





MorphicTextAdapter>>setScrollValue:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aValue: 	(0@0.0)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(296747008))

		model: 	a TextModel

		widget: 	a PluggableTextMorph(296747008)

		selector: 	nil





MorphicTextAdapter(AbstractAdapter)>>update:with:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aSymbol: 	#setScrollValue:
		anArray: 	{(0@0.0)}

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(296747008))

		model: 	a TextModel

		widget: 	a PluggableTextMorph(296747008)

		selector: 	nil





[ :aDependent | aDependent update: anAspect with: anObject ] in TextModel(Object)>>changed:with:

	Receiver: a TextModel

	Arguments and temporary variables: 

		anAspect: 	#setScrollValue:
		anObject: 	{(0@0.0)}
		aDependent: 	a MorphicTextAdapter

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	an EyeDebuggerContextInspector

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]

		behaviorHolder: 	a NewValueHolder[ nil ]

		textHolder: 	a CollectionValueHolder[ 'ByteSymbol(Symbol)>>changeBinding:' ]

		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		doItReceiver: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (1 to: 0) ]

		scrollValue: 	a NewValueHolder[ (0@0.0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





DependentsArray>>do:

	Receiver: a DependentsArray(a MorphicTextAdapter)

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: anAspect with: anObject ]
		dep: 	a MorphicTextAdapter
		i: 	1

	Receiver's instance variables: 

a DependentsArray(a MorphicTextAdapter)



TextModel(Object)>>changed:with:

	Receiver: a TextModel

	Arguments and temporary variables: 

		anAspect: 	#setScrollValue:
		anObject: 	{(0@0.0)}

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	an EyeDebuggerContextInspector

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]

		behaviorHolder: 	a NewValueHolder[ nil ]

		textHolder: 	a CollectionValueHolder[ 'ByteSymbol(Symbol)>>changeBinding:' ]

		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		doItReceiver: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (1 to: 0) ]

		scrollValue: 	a NewValueHolder[ (0@0.0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





[ :newPosition | self changed: #setScrollValue: with: {newPosition} ] in TextModel>>registerEvents

	Receiver: a TextModel

	Arguments and temporary variables: 

		newPosition: 	(0@0.0)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	an EyeDebuggerContextInspector

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ false ] ]

		behaviorHolder: 	a NewValueHolder[ nil ]

		textHolder: 	a CollectionValueHolder[ 'ByteSymbol(Symbol)>>changeBinding:' ]

		actionToPerformHolder: 	a NewValueHolder[ [ :text |  ] ]

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		doItReceiver: 	a NewValueHolder[ ByteSymbol(Symbol)>>changeBinding: ]

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (1 to: 0) ]

		scrollValue: 	a NewValueHolder[ (0@0.0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | 
shifted
	ifTrue: [ SmalltalkE...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





BlockClosure>>cull:

	Receiver: [ :newPosition | self changed: #setScrollValue: with: {newPosition} ]

	Arguments and temporary variables: 

		anArg: 	(0@0.0)

	Receiver's instance variables: 

		outerContext: 	TextModel>>registerEvents

		startpc: 	141

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :newPosition | self changed: #setScrollValue: with: {newPosition} ]

	Arguments and temporary variables: 

		firstArg: 	(0@0.0)
		secondArg: 	(0@0.0)

	Receiver's instance variables: 

		outerContext: 	TextModel>>registerEvents

		startpc: 	141

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :newPosition | self changed: #setScrollValue: with: {newPosition} ]

	Arguments and temporary variables: 

		firstArg: 	(0@0.0)
		secondArg: 	(0@0.0)
		thirdArg: 	a ValueChanged

	Receiver's instance variables: 

		outerContext: 	TextModel>>registerEvents

		startpc: 	141

		numArgs: 	1







--- The full stack ---

WriteStream>>nextPut:

[ :each | 
(each handlesAnnouncement: anAnnouncement)
	ifTrue: [ s nextPut: each ] ] in [ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement: anAnnouncement)
			ifTrue: [ s nextPut: each ] ] ] in SubscriptionRegistry>>subscriptionsHandling:

IdentitySet(Set)>>do:

[ :s | 
subscriptions
	do: [ :each | 
		(each handlesAnnouncement: anAnnouncement)
			ifTrue: [ s nextPut: each ] ] ] in SubscriptionRegistry>>subscriptionsHandling:

Array class(SequenceableCollection class)>>new:streamContents:

Array class(SequenceableCollection class)>>streamContents:

SubscriptionRegistry>>subscriptionsHandling:

[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement ] in SubscriptionRegistry>>deliver:

[ aBlock value ] in SubscriptionRegistry>>protected:

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

SubscriptionRegistry>>protected:

SubscriptionRegistry>>deliver:

Announcer>>announce:

EditorFindReplaceDialogWindow(Morph)>>changed:

EditorFindReplaceDialogWindow>>update:

[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

DependentsArray>>do:

FindReplaceService(Object)>>changed:

TextMorphForEditView>>selectionChanged

PluggableTextMorph>>hScrollBarValue:

ScrollBar(Slider)>>setValue:

ScrollBar>>setValue:

PluggableTextMorph(ScrollPane)>>hScrollValue:

PluggableTextMorph(ScrollPane)>>scrollValue:

[ :w | w scrollValue: aValue ] in MorphicTextAdapter>>setScrollValue:

BlockClosure>>cull:

PluggableTextMorph(ProtoObject)>>ifNotNil:

MorphicTextAdapter(AbstractAdapter)>>widgetDo:

MorphicTextAdapter>>setScrollValue:

MorphicTextAdapter(AbstractAdapter)>>update:with:

[ :aDependent | aDependent update: anAspect with: anObject ] in TextModel(Object)>>changed:with:

DependentsArray>>do:

TextModel(Object)>>changed:with:

[ :newPosition | self changed: #setScrollValue: with: {newPosition} ] in TextModel>>registerEvents

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

BlockClosure>>cull:cull:cull:cull:

[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder>>whenChangedDo:

BlockClosure>>cull:cull:

[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:

BlockClosure>>on:do:

BlockClosure>>on:fork:

AnnouncementSubscription>>deliver:

[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:

BlockClosure>>ifCurtailed:

SubscriptionRegistry>>deliver:to:startingAt:

SubscriptionRegistry>>deliver:to:

SubscriptionRegistry>>deliver:

Announcer>>announce:

NewValueHolder>>valueChanged:

[ 
| oldValue |
oldValue := value.
value := anObject.
self valueChanged: oldValue ] in NewValueHolder>>value:

BlockClosure>>ensure:

NewValueHolder>>handleCircularReferencesWhile:

NewValueHolder>>value:

TextModel>>scrollValue:

MorphicTextAdapter>>scrollValueChanged:

WeakMessageSend>>value:

WeakMessageSend>>cull:

WeakMessageSend>>cull:cull:

[ action cull: anAnnouncement cull: announcer ] in WeakAnnouncementSubscription>>deliver:

BlockClosure>>on:do:

BlockClosure>>on:fork:

WeakAnnouncementSubscription>>deliver:

[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:

BlockClosure>>ifCurtailed:

SubscriptionRegistry>>deliver:to:startingAt:

SubscriptionRegistry>>deliver:to:

SubscriptionRegistry>>deliver:

Announcer>>announce:

PluggableTextMorph(ScrollPane)>>vScrollBarValue:

PluggableTextMorph>>vScrollBarValue:

ScrollBar(Slider)>>setValue:

ScrollBar>>setValue:

PluggableTextMorph(ScrollPane)>>vSetScrollDelta

PluggableTextMorph(ScrollPane)>>setScrollDeltas

PluggableTextMorph>>extent:

PluggableTextMorph(Morph)>>bounds:

PluggableTextMorph(Morph)>>layoutInBounds:

PluggableTextMorph(Morph)>>layoutProportionallyIn:

[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in:

Array(SequenceableCollection)>>do:

PanelMorph(Morph)>>submorphsDo:

ProportionalLayout>>layout:in:

PanelMorph(Morph)>>doLayoutIn:

[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds

BlockClosure>>on:do:

PanelMorph(Morph)>>computeFullBounds

PanelMorph(Morph)>>fullBounds

[ :m | 
| subBox |
m visible
	ifTrue: [ 
		subBox := m fullBounds.
		box ifNil: [ box := subBox copy ] ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds

Array(SequenceableCollection)>>do:

PanelMorph(Morph)>>submorphBounds

PanelMorph(Morph)>>privateFullBounds

PanelMorph(Morph)>>changed

PanelMorph(Morph)>>color:

PanelMorph>>adoptPaneColor:

[ :m | m adoptPaneColor: paneColor ] in PanelMorph(Morph)>>adoptPaneColor:

Array(SequenceableCollection)>>do:

PanelMorph(Morph)>>submorphsDo:

PanelMorph(Morph)>>adoptPaneColor:

PanelMorph>>adoptPaneColor:

SpecWindow(SystemWindow)>>addMorph:fullFrame:

SpecWindow(SystemWindow)>>addMorph:frame:

MorphicWindowAdapter>>addModelIn:withSpecLayout:

MorphicWindowAdapter(AbstractAdapter)>>update:with:

[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:

DependentsArray>>do:

WindowModel(Object)>>changed:with:

WindowModel>>addModelIn:withSpecLayout:

WindowModel>>buildWithSpecLayout:

WindowModel>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpec:

SpecDebugger(ComposableModel)>>openWithSpec

SpecDebugger>>openFullNoSuspendLabel:

[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ] in [ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

BlockClosure>>on:do:

[ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

WorldState>>runStepMethodsIn:

WorldMorph>>runStepMethods

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:24.810126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:24.989126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:25.170126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:25.349126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:57:28.761126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ aBlock value ]
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ aBlock value ]

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		interestedSubscriptions: 	nil
		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





Announcer>>announce:

	Receiver: an Announcer

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		announcement: 	a MorphChanged

	Receiver's instance variables: 

		registry: 	a SubscriptionRegistry





EditorFindReplaceDialogWindow(Morph)>>changed:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		anAspect: 	#replaceEnabled

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





EditorFindReplaceDialogWindow>>update:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		aSymbol: 	#findReplaceSelection
		si: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection
		aDependent: 	an EditorFindReplaceDialogWindow(204210176)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





DependentsArray>>do:

	Receiver: a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	an EditorFindReplaceDialogWindow(204210176)
		i: 	1

	Receiver's instance variables: 

a DependentsArray(an EditorFindReplaceDialogWindow(204210176))



FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleInteraction:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		interactionBlock: 	[ editor mouseMove: event ]
		oldEditor: 	a SmalltalkEditor
		oldParagraph: 	a Paragraph
		oldText: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView>>handleInteraction:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		interActionBlock: 	[ editor mouseMove: event ]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>mouseMove:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		event: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView>>mouseMove:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		evt: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]
		editEvt: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>handleMouseMove:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		anEvent: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





MouseMoveEvent>>sentTo:

	Receiver: [(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]

	Arguments and temporary variables: 

		anObject: 	a TextMorphForEditView(927203328)

	Receiver's instance variables: 

		timeStamp: 	2499984

		source: 	a HandMorph(760479744)

		windowIndex: 	nil

		type: 	#mouseMove

		buttons: 	4

		position: 	(67.0@96.0)

		handler: 	nil

		wasHandled: 	true

		startPoint: 	(75.0@105.0)

		trail: 	{(452@134.0). (444@125)}





TextMorphForEditView(Morph)>>handleEvent:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		anEvent: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





MorphicEventDispatcher>>dispatchDefault:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]
		aMorph: 	a TextMorphForEditView(927203328)
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





MorphicEventDispatcher>>dispatchEvent:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]
		aMorph: 	a TextMorphForEditView(927203328)

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





TextMorphForEditView(Morph)>>processEvent:using:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		anEvent: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]
		defaultDispatcher: 	a MorphicEventDispatcher

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





MorphicEventDispatcher>>dispatchDefault:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a TransformMorph(397934592)
		localEvt: 	[(75.0@105.0) (67.0@96.0) mouseMove red 2499984 nil]
		index: 	1
		child: 	a TextMorphForEditView(927203328)
		morphs: 	an Array(a TextMorphForEditView(927203328))
		inside: 	false

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





MorphicEventDispatcher>>dispatchEvent:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a TransformMorph(397934592)

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





TransformMorph(Morph)>>processEvent:using:

	Receiver: a TransformMorph(397934592)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		defaultDispatcher: 	a MorphicEventDispatcher

	Receiver's instance variables: 

		bounds: 	(374.0@29.0) corner: (799.0@194.0)

		owner: 	a PluggableTextMorph(736886784)

		submorphs: 	an Array(a TextMorphForEditView(927203328))

		fullBounds: 	(374.0@29.0) corner: (799.0@194.0)

		color: 	Color transparent

		extension: 	a MorphExtension (432013312) [other:  (kmDispatcher -> a KMDispatche...etc...

		transform: 	a MorphicTransform(angle = 0.0; scale = 1.0; offset = (-377.0@ -29.0...etc...

		smoothing: 	1

		localBounds: 	(0@0) corner: (419@178)





MorphicEventDispatcher>>dispatchDefault:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a PluggableTextMorph(736886784)
		localEvt: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		index: 	2
		child: 	a TransformMorph(397934592)
		morphs: 	an Array(a ScrollBar(776732672) a TransformMorph(397934592))
		inside: 	false

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





MorphicEventDispatcher>>dispatchEvent:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a PluggableTextMorph(736886784)

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





PluggableTextMorph(Morph)>>processEvent:using:

	Receiver: a PluggableTextMorph(736886784)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		defaultDispatcher: 	a MorphicEventDispatcher

	Receiver's instance variables: 

		bounds: 	(373.0@28.0) corner: (813.0@195.0)

		owner: 	a SystemWindow(825753600)

		submorphs: 	an Array(a ScrollBar(776732672) a TransformMorph(397934592))

		fullBounds: 	(373@28) corner: (813@195)

		color: 	Color white

		extension: 	a MorphExtension (905969664) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(776732672)

		scroller: 	a TransformMorph(397934592)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	true

		hScrollBar: 	a ScrollBar(548143104)

		textMorph: 	a TextMorphForEditView(927203328)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 400)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





MorphicEventDispatcher>>dispatchDefault:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a SystemWindow(825753600)
		localEvt: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		index: 	10
		child: 	a PluggableTextMorph(736886784)
		morphs: 	an Array(a WindowEdgeGripMorph(711720960) a WindowEdgeGripMorph(5360844...etc...
		inside: 	false

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





MorphicEventDispatcher>>dispatchEvent:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a SystemWindow(825753600)

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





SystemWindow(Morph)>>processEvent:using:

	Receiver: a SystemWindow(825753600)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		defaultDispatcher: 	a MorphicEventDispatcher

	Receiver's instance variables: 

		bounds: 	(368.0@0.0) corner: (818.0@200.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	an Array(a WindowEdgeGripMorph(711720960) a WindowEdgeGripMorph(5360...etc...

		fullBounds: 	(368@0) corner: (818@200)

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (982777856) [other:  (paneColor -> (Color r: 0.8230...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		labelString: 	'Workspace'

		stripes: 	an Array(a Morph(148897792) a Morph(160694272))

		label: 	a LabelMorph(1070071808)'Workspace'

		closeBox: 	a MultistateButtonMorph(401604608)

		collapseBox: 	a MultistateButtonMorph(919076864)

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PluggableTextMorph(736886784))

		collapsedFrame: 	nil

		fullFrame: 	(368.0@0.0) corner: (818.0@200.0)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(794296320)

		mustNotClose: 	false

		labelWidgetAllowance: 	133

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(187695104)

		expandBox: 	a MultistateButtonMorph(166985728)

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	true





MorphicEventDispatcher>>dispatchDefault:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a WorldMorph(511705088) [world]
		localEvt: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		index: 	2
		child: 	a SystemWindow(825753600)
		morphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(825753600) a Nautilus...etc...
		inside: 	false

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





MorphicEventDispatcher>>dispatchEvent:with:

	Receiver: a MorphicEventDispatcher

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		aMorph: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		lastType: 	#mouseMove

		lastDispatch: 	#dispatchDefault:with:





WorldMorph(Morph)>>processEvent:using:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		defaultDispatcher: 	a MorphicEventDispatcher

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(825753600) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





WorldMorph(Morph)>>processEvent:

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(825753600) a Nauti...etc...

		fullBounds: 	(0@0) corner: (1520@785)

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





HandMorph>>sendEvent:focus:clear:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		focusHolder: 	nil
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(436@116.0) corner: (452@132.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(436@116.0) corner: (452@132.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(927203328)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

		targetOffset: 	(57.0@148.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2499984 444 125 4 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





HandMorph>>sendMouseEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(436@116.0) corner: (452@132.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(436@116.0) corner: (452@132.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(927203328)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

		targetOffset: 	(57.0@148.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2499984 444 125 4 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





HandMorph>>handleEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		evt: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]
		pos: 	(444@125)

	Receiver's instance variables: 

		bounds: 	(436@116.0) corner: (452@132.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(436@116.0) corner: (452@132.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(927203328)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

		targetOffset: 	(57.0@148.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2499984 444 125 4 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0





HandMorph>>moveToEvent:

	Receiver: a HandMorph(760479744)

	Arguments and temporary variables: 

		anEvent: 	[(444@125) mouseDown red 2499984 nil]

	Receiver's instance variables: 

		bounds: 	(436@116.0) corner: (452@132.0)

		owner: 	a WorldMorph(511705088) [world]

		submorphs: 	#()

		fullBounds: 	(436@116.0) corner: (452@132.0)

		color: 	Color blue

		extension: 	a MorphExtension (114556928)

		mouseFocus: 	nil

		keyboardFocus: 	a TextMorphForEditView(927203328)

		eventListeners: 	nil

		mouseListeners: 	nil

		keyboardListeners: 	nil

		mouseClickState: 	nil

		mouseOverHandler: 	a MouseOverHandler

		lastMouseEvent: 	[(452@134.0) (444@125) mouseMove red 2499984 nil]

		targetOffset: 	(57.0@148.0)

		damageRecorder: 	a DamageRecorder

		cacheCanvas: 	nil

		cachedCanvasHasHoles: 	false

		temporaryCursor: 	Form(16x16x8)

		temporaryCursorOffset: 	(-8@ -9)

		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...

		hasChanged: 	true

		savedPatch: 	nil

		lastEventBuffer: 	#(1 2499984 444 125 4 0 1 1)

		lastKeyScanCode: 	80

		combinedChar: 	nil

		eventSource: 	nil

		lastSystemEvent: 	nil

		captureBlock: 	nil

		recentModifiers: 	0







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

SubscriptionRegistry>>protected:

SubscriptionRegistry>>deliver:

Announcer>>announce:

EditorFindReplaceDialogWindow(Morph)>>changed:

EditorFindReplaceDialogWindow>>update:

[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

DependentsArray>>do:

FindReplaceService(Object)>>changed:

TextMorphForEditView>>selectionChanged

TextMorphForEditView(TextMorph)>>handleInteraction:

TextMorphForEditView>>handleInteraction:

TextMorphForEditView(TextMorph)>>mouseMove:

TextMorphForEditView>>mouseMove:

TextMorphForEditView(TextMorph)>>handleMouseMove:

MouseMoveEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

MorphicEventDispatcher>>dispatchDefault:with:

MorphicEventDispatcher>>dispatchEvent:with:

TextMorphForEditView(Morph)>>processEvent:using:

MorphicEventDispatcher>>dispatchDefault:with:

MorphicEventDispatcher>>dispatchEvent:with:

TransformMorph(Morph)>>processEvent:using:

MorphicEventDispatcher>>dispatchDefault:with:

MorphicEventDispatcher>>dispatchEvent:with:

PluggableTextMorph(Morph)>>processEvent:using:

MorphicEventDispatcher>>dispatchDefault:with:

MorphicEventDispatcher>>dispatchEvent:with:

SystemWindow(Morph)>>processEvent:using:

MorphicEventDispatcher>>dispatchDefault:with:

MorphicEventDispatcher>>dispatchEvent:with:

WorldMorph(Morph)>>processEvent:using:

WorldMorph(Morph)>>processEvent:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendMouseEvent:

HandMorph>>handleEvent:

HandMorph>>moveToEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:10.075126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ aBlock value ]
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ aBlock value ]

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		interestedSubscriptions: 	nil
		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





Announcer>>announce:

	Receiver: an Announcer

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		announcement: 	a MorphChanged

	Receiver's instance variables: 

		registry: 	a SubscriptionRegistry





EditorFindReplaceDialogWindow(Morph)>>changed:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		anAspect: 	#replaceEnabled

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





EditorFindReplaceDialogWindow>>update:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		aSymbol: 	#findReplaceSelection
		si: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection
		aDependent: 	an EditorFindReplaceDialogWindow(204210176)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





DependentsArray>>do:

	Receiver: a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	an EditorFindReplaceDialogWindow(204210176)
		i: 	1

	Receiver's instance variables: 

a DependentsArray(an EditorFindReplaceDialogWindow(204210176))



FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(536870912)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(277610496)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (585629696) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(960233472)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>installEditorToReplace:

	Receiver: a TextMorphForEditView(536870912)

	Arguments and temporary variables: 

		priorEditor: 	nil
		stateArray: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(277610496)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (585629696) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(960233472)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>editor

	Receiver: a TextMorphForEditView(536870912)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(277610496)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (585629696) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(960233472)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>configureTextMorph:

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(536870912)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph:

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(536870912)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setTextBasic:

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 

		aText: 	'sender
	"Answer the context that sent the message that created the rece...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setText:

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 

		aText: 	'sender
	"Answer the context that sent the message that created the rece...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

	Receiver: a PluggableTextMorph(960233472)

	Arguments and temporary variables: 

		anObject: 	a MorphicTextAdapter
		getTextSel: 	#getText
		setTextSel: 	#accept:notifying:
		getSelectionSel: 	#readSelection
		getMenuSel: 	#codePaneMenu:shifted:
		setSelectionSel: 	#setSelection:

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(277610496))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (756809728)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(988020736)

		scroller: 	a TransformMorph(277610496)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(753401856)

		textMorph: 	a TextMorphForEditView(536870912)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#on:text:accept:readSelection:menu:setSelection:
		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...
		numArgs: 	6
		selector: 	#on:text:accept:readSelection:menu:setSelection:

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





MorphicTextAdapter(AbstractAdapter)>>buildWidget

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(960233472))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





MorphicTextAdapter(AbstractAdapter)>>adapt:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(960233472))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#adapt:
		args: 	an Array(a TextModel)

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a TextModel)
		numArgs: 	1
		selector: 	#adapt:

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





SpecInterpreter class>>private_buildWidgetFor:withSpec:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel
		aSymbol: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





TextModel(ComposableModel)>>private_buildWithSpec:

	Receiver: a TextModel

	Arguments and temporary variables: 

		aSpec: 	#defaultSpec
		widget: 	nil

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ MethodContext ]

		textHolder: 	a CollectionValueHolder[ 'sender
	"Answer the context that sent the...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ MethodContext(ContextPart)>>sender ]

		doItReceiver: 	a NewValueHolder[ [ 
codeLine value.
label binding value ] in [ 
...etc...

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (81 to: 87) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





TextModel(ComposableModel)>>private_buildWithSpec

	Receiver: a TextModel

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ MethodContext ]

		textHolder: 	a CollectionValueHolder[ 'sender
	"Answer the context that sent the...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ MethodContext(ContextPart)>>sender ]

		doItReceiver: 	a NewValueHolder[ [ 
codeLine value.
label binding value ] in [ 
...etc...

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (81 to: 87) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





SpecInterpreter>>returnInterpretationOf:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		newInstance: 	a TextModel
		result: 	a TextModel
		return: 	nil

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aSelector: 	#specOptimized
		newInstance: 	a TextModel

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

SubscriptionRegistry>>protected:

SubscriptionRegistry>>deliver:

Announcer>>announce:

EditorFindReplaceDialogWindow(Morph)>>changed:

EditorFindReplaceDialogWindow>>update:

[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

DependentsArray>>do:

FindReplaceService(Object)>>changed:

TextMorphForEditView>>selectionChanged

TextMorphForEditView(TextMorph)>>installEditorToReplace:

TextMorphForEditView(TextMorph)>>editor

PluggableTextMorph>>configureTextMorph:

PluggableTextMorph>>textMorph:

PluggableTextMorph>>textMorph

PluggableTextMorph>>setTextBasic:

PluggableTextMorph>>setText:

PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

MorphicTextAdapter(AbstractAdapter)>>buildWidget

MorphicTextAdapter(AbstractAdapter)>>adapt:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

SpecInterpreter class>>private_buildWidgetFor:withSpec:

TextModel(ComposableModel)>>private_buildWithSpec:

TextModel(ComposableModel)>>private_buildWithSpec

SpecInterpreter>>returnInterpretationOf:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

SpecInterpreter>>computeSpecFrom:selector:

SpecInterpreter>>retrieveSpecFrom:selector:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex

Array(SequenceableCollection)>>collect:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:

BlockClosure>>ensure:

SpecInterpreter class>>interpretASpec:model:selector:

SpecInterpreter class>>interpretASpec:model:

SpecDebugger(ComposableModel)>>buildWithSpecLayout:

MorphicWindowAdapter>>addModelIn:withSpecLayout:

MorphicWindowAdapter(AbstractAdapter)>>update:with:

[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:

DependentsArray>>do:

WindowModel(Object)>>changed:with:

WindowModel>>addModelIn:withSpecLayout:

WindowModel>>buildWithSpecLayout:

WindowModel>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpec:

SpecDebugger(ComposableModel)>>openWithSpec

SpecDebugger>>openFullNoSuspendLabel:

[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ] in [ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

BlockClosure>>on:do:

[ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

WorldState>>runStepMethodsIn:

WorldMorph>>runStepMethods

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:10.450126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ aBlock value ]
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ aBlock value ]

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		interestedSubscriptions: 	nil
		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





Announcer>>announce:

	Receiver: an Announcer

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		announcement: 	a MorphChanged

	Receiver's instance variables: 

		registry: 	a SubscriptionRegistry





EditorFindReplaceDialogWindow(Morph)>>changed:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		anAspect: 	#replaceEnabled

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





EditorFindReplaceDialogWindow>>update:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		aSymbol: 	#findReplaceSelection
		si: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection
		aDependent: 	an EditorFindReplaceDialogWindow(204210176)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





DependentsArray>>do:

	Receiver: a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	an EditorFindReplaceDialogWindow(204210176)
		i: 	1

	Receiver's instance variables: 

a DependentsArray(an EditorFindReplaceDialogWindow(204210176))



FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(59506688)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(515375104)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (120324096) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(589037568)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>installEditorToReplace:

	Receiver: a TextMorphForEditView(59506688)

	Arguments and temporary variables: 

		priorEditor: 	nil
		stateArray: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(515375104)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (120324096) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(589037568)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>editor

	Receiver: a TextMorphForEditView(59506688)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(515375104)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (120324096) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(589037568)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>configureTextMorph:

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(59506688)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph:

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(59506688)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setTextBasic:

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 

		aText: 	'nextPut: anObject 
	"Primitive. Insert the argument at the next positio...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setText:

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 

		aText: 	'nextPut: anObject 
	"Primitive. Insert the argument at the next positio...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

	Receiver: a PluggableTextMorph(589037568)

	Arguments and temporary variables: 

		anObject: 	a MorphicTextAdapter
		getTextSel: 	#getText
		setTextSel: 	#accept:notifying:
		getSelectionSel: 	#readSelection
		getMenuSel: 	#codePaneMenu:shifted:
		setSelectionSel: 	#setSelection:

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(515375104))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (234881024)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(616824832)

		scroller: 	a TransformMorph(515375104)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(581173248)

		textMorph: 	a TextMorphForEditView(59506688)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#on:text:accept:readSelection:menu:setSelection:
		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...
		numArgs: 	6
		selector: 	#on:text:accept:readSelection:menu:setSelection:

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





MorphicTextAdapter(AbstractAdapter)>>buildWidget

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(589037568))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





MorphicTextAdapter(AbstractAdapter)>>adapt:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(589037568))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#adapt:
		args: 	an Array(a TextModel)

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a TextModel)
		numArgs: 	1
		selector: 	#adapt:

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





SpecInterpreter class>>private_buildWidgetFor:withSpec:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel
		aSymbol: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





TextModel(ComposableModel)>>private_buildWithSpec:

	Receiver: a TextModel

	Arguments and temporary variables: 

		aSpec: 	#defaultSpec
		widget: 	nil

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ WriteStream ]

		textHolder: 	a CollectionValueHolder[ 'nextPut: anObject 
	"Primitive. Insert th...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ WriteStream>>nextPut: ]

		doItReceiver: 	a NewValueHolder[ a WriteStream ]

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (428 to: 435) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





TextModel(ComposableModel)>>private_buildWithSpec

	Receiver: a TextModel

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ WriteStream ]

		textHolder: 	a CollectionValueHolder[ 'nextPut: anObject 
	"Primitive. Insert th...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ WriteStream>>nextPut: ]

		doItReceiver: 	a NewValueHolder[ a WriteStream ]

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (428 to: 435) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





SpecInterpreter>>returnInterpretationOf:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		newInstance: 	a TextModel
		result: 	a TextModel
		return: 	nil

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aSelector: 	#specOptimized
		newInstance: 	a TextModel

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

SubscriptionRegistry>>protected:

SubscriptionRegistry>>deliver:

Announcer>>announce:

EditorFindReplaceDialogWindow(Morph)>>changed:

EditorFindReplaceDialogWindow>>update:

[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

DependentsArray>>do:

FindReplaceService(Object)>>changed:

TextMorphForEditView>>selectionChanged

TextMorphForEditView(TextMorph)>>installEditorToReplace:

TextMorphForEditView(TextMorph)>>editor

PluggableTextMorph>>configureTextMorph:

PluggableTextMorph>>textMorph:

PluggableTextMorph>>textMorph

PluggableTextMorph>>setTextBasic:

PluggableTextMorph>>setText:

PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

MorphicTextAdapter(AbstractAdapter)>>buildWidget

MorphicTextAdapter(AbstractAdapter)>>adapt:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

SpecInterpreter class>>private_buildWidgetFor:withSpec:

TextModel(ComposableModel)>>private_buildWithSpec:

TextModel(ComposableModel)>>private_buildWithSpec

SpecInterpreter>>returnInterpretationOf:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

SpecInterpreter>>computeSpecFrom:selector:

SpecInterpreter>>retrieveSpecFrom:selector:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex

Array(SequenceableCollection)>>collect:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:

BlockClosure>>ensure:

SpecInterpreter class>>interpretASpec:model:selector:

SpecInterpreter class>>interpretASpec:model:

SpecDebugger(ComposableModel)>>buildWithSpecLayout:

MorphicWindowAdapter>>addModelIn:withSpecLayout:

MorphicWindowAdapter(AbstractAdapter)>>update:with:

[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:

DependentsArray>>do:

WindowModel(Object)>>changed:with:

WindowModel>>addModelIn:withSpecLayout:

WindowModel>>buildWithSpecLayout:

WindowModel>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpec:

SpecDebugger(ComposableModel)>>openWithSpec

SpecDebugger>>openFullNoSuspendLabel:

[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ] in [ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

BlockClosure>>on:do:

[ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

WorldState>>runStepMethodsIn:

WorldMorph>>runStepMethods

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:10.725126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:10.904126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:11.086126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:11.266126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:11.368126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ aBlock value ]
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ aBlock value ]

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





SubscriptionRegistry>>protected:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		aBlock: 	[ interestedSubscriptions := self subscriptionsHandling: anAnnouncement...etc...

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





SubscriptionRegistry>>deliver:

	Receiver: a SubscriptionRegistry

	Arguments and temporary variables: 

		interestedSubscriptions: 	nil
		anAnnouncement: 	a MorphChanged

	Receiver's instance variables: 

		subscriptions: 	an IdentitySet(a WeakAnnouncementSubscription a WeakAnnouncement...etc...

		monitor: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := m...etc...





Announcer>>announce:

	Receiver: an Announcer

	Arguments and temporary variables: 

		anAnnouncement: 	a MorphChanged
		announcement: 	a MorphChanged

	Receiver's instance variables: 

		registry: 	a SubscriptionRegistry





EditorFindReplaceDialogWindow(Morph)>>changed:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		anAspect: 	#replaceEnabled

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





EditorFindReplaceDialogWindow>>update:

	Receiver: an EditorFindReplaceDialogWindow(204210176)

	Arguments and temporary variables: 

		aSymbol: 	#findReplaceSelection
		si: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (334@215)

		owner: 	nil

		submorphs: 	an Array(a WindowEdgeGripMorph(827326464) a WindowEdgeGripMorph(6637...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...

		extension: 	a MorphExtension (379846656) [other:  (minimumExtent -> (136.0@18)) ...etc...

		borderWidth: 	1

		borderColor: 	Color lightGray

		model: 	a TextMorphForEditView(927203328)

		open: 	false

		accessor: 	nil

		labelString: 	'Find & Replace'

		stripes: 	an Array(a Morph(60817408) a Morph(90701824))

		label: 	a LabelMorph(503316480)'Find & Replace'

		closeBox: 	a MultistateButtonMorph(722731008)

		collapseBox: 	nil

		activeOnlyOnTop: 	true

		paneMorphs: 	an Array(a PanelMorph(155713536))

		collapsedFrame: 	nil

		fullFrame: 	(0@0) corner: (334@215)

		isCollapsed: 	false

		menuBox: 	a MultistateButtonMorph(283901952)

		mustNotClose: 	false

		labelWidgetAllowance: 	0

		updatablePanes: 	#()

		labelArea: 	an AlignmentMorph(153878528)

		expandBox: 	nil

		embeddable: 	nil

		announcer: 	an Announcer

		menuBuilder: 	nil

		isResizeable: 	nil

		cancelled: 	true

		state: 	a FindReplaceService





[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection
		aDependent: 	an EditorFindReplaceDialogWindow(204210176)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





DependentsArray>>do:

	Receiver: a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	an EditorFindReplaceDialogWindow(204210176)
		i: 	1

	Receiver's instance variables: 

a DependentsArray(an EditorFindReplaceDialogWindow(204210176))



FindReplaceService(Object)>>changed:

	Receiver: a FindReplaceService

	Arguments and temporary variables: 

		aParameter: 	#findReplaceSelection

	Receiver's instance variables: 

		dependents: 	a DependentsArray(an EditorFindReplaceDialogWindow(204210176))

		findText: 	a Text for ''

		replaceText: 	''

		caseSensitive: 	false

		entireWordsOnly: 	false

		wrapAround: 	true

		searchBackwards: 	false

		findStartIndex: 	401

		isRegex: 	false





TextMorphForEditView>>selectionChanged

	Receiver: a TextMorphForEditView(223608832)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(575668224)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (284426240) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(613154816)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>installEditorToReplace:

	Receiver: a TextMorphForEditView(223608832)

	Arguments and temporary variables: 

		priorEditor: 	nil
		stateArray: 	nil

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(575668224)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (284426240) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(613154816)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





TextMorphForEditView(TextMorph)>>editor

	Receiver: a TextMorphForEditView(223608832)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (50@14)

		owner: 	a TransformMorph(575668224)

		submorphs: 	#()

		fullBounds: 	nil

		color: 	Color black

		extension: 	a MorphExtension (284426240) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for ''

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a PluggableTextMorph(613154816)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>configureTextMorph:

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(223608832)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph:

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 

		aTextMorph: 	a TextMorphForEditView(223608832)

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>textMorph

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setTextBasic:

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 

		aText: 	'newProcess
	"Answer a Process running the code in the receiver. The pro...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>setText:

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 

		aText: 	'newProcess
	"Answer a Process running the code in the receiver. The pro...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

	Receiver: a PluggableTextMorph(613154816)

	Arguments and temporary variables: 

		anObject: 	a MorphicTextAdapter
		getTextSel: 	#getText
		setTextSel: 	#accept:notifying:
		getSelectionSel: 	#readSelection
		getMenuSel: 	#codePaneMenu:shifted:
		setSelectionSel: 	#setSelection:

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (150@120)

		owner: 	nil

		submorphs: 	an Array(a TransformMorph(575668224))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (420216832)

		borderWidth: 	1

		borderColor: 	Color black

		model: 	a MorphicTextAdapter

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(640942080)

		scroller: 	a TransformMorph(575668224)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(641466368)

		textMorph: 	a TextMorphForEditView(223608832)

		getTextSelector: 	#getText

		setTextSelector: 	#accept:notifying:

		getSelectionSelector: 	#readSelection

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	nil

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	#setSelection:





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#on:text:accept:readSelection:menu:setSelection:
		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a MorphicTextAdapter #getText #accept:notifying: #readSelection ...etc...
		numArgs: 	6
		selector: 	#on:text:accept:readSelection:menu:setSelection:

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aSelector: 	nil
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		model: 	a MorphicTextAdapter

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#PluggableTextMorph #color: #(#model #color) #classOrMetaCl...etc...

		index: 	13





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	a SpecLayout
		aModel: 	a MorphicTextAdapter
		aSelector: 	nil

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





MorphicTextAdapter(AbstractAdapter)>>buildWidget

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(613154816))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





MorphicTextAdapter(AbstractAdapter)>>adapt:

	Receiver: a MorphicTextAdapter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a PluggableTextMorph(613154816))

		model: 	a TextModel

		widget: 	nil

		selector: 	nil





SpecInterpreter>>actionToPerformWithSelector:arguments:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		selector: 	#adapt:
		args: 	an Array(a TextModel)

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>performNextSelectorAndIncrementIndex

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		args: 	an Array(a TextModel)
		numArgs: 	1
		selector: 	#adapt:

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aSelector: 	#defaultSpec
		newInstance: 	nil

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		model: 	a TextModel

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#TextAdapter #adapt: #(#model))

		index: 	4





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#TextAdapter #adapt: #(#model))
		aModel: 	a TextModel
		aSelector: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





SpecInterpreter class>>private_buildWidgetFor:withSpec:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aComposableModel: 	a TextModel
		aSymbol: 	#defaultSpec

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings





TextModel(ComposableModel)>>private_buildWithSpec:

	Receiver: a TextModel

	Arguments and temporary variables: 

		aSpec: 	#defaultSpec
		widget: 	nil

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ BlockClosure ]

		textHolder: 	a CollectionValueHolder[ 'newProcess
	"Answer a Process running the...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ [ 
self value.
Processor terminateActive ] in Bl...etc...

		doItReceiver: 	a NewValueHolder[ [ 
World doOneCycle.
Processor yield.
false ] ]...etc...

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (163 to: 166) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





TextModel(ComposableModel)>>private_buildWithSpec

	Receiver: a TextModel

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a MorphicTextAdapter)

		focusOrder: 	nil

		owner: 	a SpecDebugger

		window: 	a NewValueHolder[ nil ]

		spec: 	a SpecWrapper

		extentHolder: 	a NewValueHolder[ nil ]

		needRebuild: 	a NewValueHolder[ true ]

		additionalKeyBindings: 	a Dictionary()

		announcer: 	a NewValueHolder[ an Announcer ]

		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]

		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]

		windowIcon: 	a NewValueHolder[ nil ]

		aboutText: 	a NewValueHolder[ nil ]

		askOkToClose: 	a NewValueHolder[ false ]

		titleHolder: 	a CollectionValueHolder[ 'Text' ]

		helpHolder: 	a NewValueHolder[ nil ]

		borderWidth: 	a NewValueHolder[ 0 ]

		borderColor: 	a NewValueHolder[ Color transparent ]

		enabledHolder: 	a NewValueHolder[ true ]

		dragEnabled: 	a NewValueHolder[ false ]

		dropEnabled: 	a NewValueHolder[ false ]

		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]

		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...

		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]

		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...

		color: 	a NewValueHolder[ Color white ]

		aboutToStyleHolder: 	a NewValueHolder[ [ aBoolean ] ]

		behaviorHolder: 	a NewValueHolder[ BlockClosure ]

		textHolder: 	a CollectionValueHolder[ 'newProcess
	"Answer a Process running the...etc...

		actionToPerformHolder: 	a NewValueHolder[ [ :text :notifyer | self recompileMeth...etc...

		readSelectionHolder: 	a NewValueHolder[ [ selection value ] ]

		actionPerformedHolder: 	a CollectionValueHolder[ '' ]

		isCodeCompletionAllowedHolder: 	a NewValueHolder[ true ]

		doItContext: 	a NewValueHolder[ [ 
self value.
Processor terminateActive ] in Bl...etc...

		doItReceiver: 	a NewValueHolder[ [ 
World doOneCycle.
Processor yield.
false ] ]...etc...

		hasUnacceptedEdits: 	a NewValueHolder[ false ]

		selection: 	a CollectionValueHolder[ (163 to: 166) ]

		scrollValue: 	a NewValueHolder[ (0@0) ]

		menuHolder: 	a NewValueHolder[ [ :menu :shifted | self codeContextMenu: menu shi...etc...

		autoAccept: 	a NewValueHolder[ false ]

		wantsVisualFeedback: 	a NewValueHolder[ true ]

		askBeforeDiscardingEdits: 	a NewValueHolder[ true ]





SpecInterpreter>>returnInterpretationOf:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		newInstance: 	a TextModel
		result: 	a TextModel
		return: 	nil

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aSelector: 	#specOptimized
		newInstance: 	a TextModel

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter>>interpretASpec:model:selector:

	Receiver: a SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		model: 	a SpecDebugger

		spec: 	a SpecWrapper

		arrayToInterpret: 	#(#model #code)

		index: 	3





SpecInterpreter class>>private_interpretASpec:model:selector:

	Receiver: SpecInterpreter

	Arguments and temporary variables: 

		aPresenter: 	#(#model #code)
		aModel: 	a SpecDebugger
		aSelector: 	#specOptimized

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#actionToPerformWithSelector:arguments:->SpecInt...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	#(#model #spec #arrayToInterpret #index)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SpecInterpreter

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Spec-Core'

		traitComposition: 	{}

		localSelectors: 	nil

		bindings: 	a MorphicAdapterBindings







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

SubscriptionRegistry>>protected:

SubscriptionRegistry>>deliver:

Announcer>>announce:

EditorFindReplaceDialogWindow(Morph)>>changed:

EditorFindReplaceDialogWindow>>update:

[ :aDependent | aDependent update: aParameter ] in FindReplaceService(Object)>>changed:

DependentsArray>>do:

FindReplaceService(Object)>>changed:

TextMorphForEditView>>selectionChanged

TextMorphForEditView(TextMorph)>>installEditorToReplace:

TextMorphForEditView(TextMorph)>>editor

PluggableTextMorph>>configureTextMorph:

PluggableTextMorph>>textMorph:

PluggableTextMorph>>textMorph

PluggableTextMorph>>setTextBasic:

PluggableTextMorph>>setText:

PluggableTextMorph>>on:text:accept:readSelection:menu:setSelection:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

MorphicTextAdapter(AbstractAdapter)>>buildWidget

MorphicTextAdapter(AbstractAdapter)>>adapt:

SpecInterpreter>>actionToPerformWithSelector:arguments:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

SpecInterpreter class>>private_buildWidgetFor:withSpec:

TextModel(ComposableModel)>>private_buildWithSpec:

TextModel(ComposableModel)>>private_buildWithSpec

SpecInterpreter>>returnInterpretationOf:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

SpecInterpreter>>computeSpecFrom:selector:

SpecInterpreter>>retrieveSpecFrom:selector:

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ :each | self class private_interpretASpec: each model: model selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex

Array(SequenceableCollection)>>collect:

SpecInterpreter>>performNextSelectorAndIncrementIndex

SpecInterpreter>>interpretASpec:selector:

SpecInterpreter>>interpretASpec:model:selector:

SpecInterpreter class>>private_interpretASpec:model:selector:

[ result := self private_interpretASpec: aPresenter model: aModel selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector:

BlockClosure>>ensure:

SpecInterpreter class>>interpretASpec:model:selector:

SpecInterpreter class>>interpretASpec:model:

SpecDebugger(ComposableModel)>>buildWithSpecLayout:

MorphicWindowAdapter>>addModelIn:withSpecLayout:

MorphicWindowAdapter(AbstractAdapter)>>update:with:

[ :aDependent | aDependent update: anAspect with: anObject ] in WindowModel(Object)>>changed:with:

DependentsArray>>do:

WindowModel(Object)>>changed:with:

WindowModel>>addModelIn:withSpecLayout:

WindowModel>>buildWithSpecLayout:

WindowModel>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpecLayout:

SpecDebugger(ComposableModel)>>openWithSpec:

SpecDebugger(ComposableModel)>>openWithSpec

SpecDebugger>>openFullNoSuspendLabel:

[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ] in [ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

BlockClosure>>on:do:

[ 
[ 
debugger process: process controller: nil context: context.	"schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."	"self defer: ["
bool
	ifTrue: [ debugger openFullNoSuspendLabel: title ]
	ifFalse: [ debugger openNotifierContents: contentsStringOrNil label: title ].
debugger errorWasInUIProcess: errorWasInUIProcess ]
	on: Error
	do: [ :ex | 
		Smalltalk tools debugger
			primitiveError:
				'Orginal error: ' , title asString
					,
						'.
	Smalltalk tools debugger error: '
					,
						([ ex description ]
							on: Error
							do: [ 'a ' , ex class printString ]) , ':' ] ] in MorphicUIManager>>openDebuggerOn:context:label:contents:fullView:

WorldState>>runStepMethodsIn:

WorldMorph>>runStepMethods

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 1:58:11.643126 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 2:07:12.881934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 2:07:40.256934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG(Object)>>isMemberOf:

	Receiver: a PROG

	Arguments and temporary variables: 

		aClass: 	Binding

	Receiver's instance variables: 

		lastCodeDone: 	true





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

PROG(Object)>>isMemberOf:

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 2:11:34.665934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 2:16:00.524934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Paragraph>>recomposeFrom:to:delta:

	Receiver: a Paragraph

	Arguments and temporary variables: 

		start: 	14772
		stop: 	14773
		delta: 	2
		startLine: 	7385
		newLines: 	an OrderedCollection(a TextLine 1 to: 2 a TextLine 3 to: 4 a TextLine...etc...

	Receiver's instance variables: 

		text: 	a Text for '0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0...etc...

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		firstCharacterIndex: 	1

		container: 	(0@0) corner: (313@9999999)

		lines: 	an Array(a TextLine 1 to: 2 a TextLine 3 to: 4 a TextLine 5 to: 6 a Text...etc...

		positionWhenComposed: 	(0@0)

		offsetToEnd: 	17

		maxRightX: 	8

		selectionStart: 	a CharacterBlock with index 14772 and character Character cr an...etc...

		selectionStop: 	a CharacterBlock with index 14772 and character Character cr and...etc...

		wantsColumnBreaks: 	false

		focused: 	false

		caretRect: 	nil

		showCaret: 	nil

		findReplaceSelectionRegex: 	nil

		secondarySelection: 	nil

		extraSelectionBlocks: 	nil

		refreshExtraSelection: 	true

		composer: 	a TextComposer





Paragraph>>replaceFrom:to:with:

	Receiver: a Paragraph

	Arguments and temporary variables: 

		start: 	14772
		stop: 	14771
		aText: 	a Text for '
0'

	Receiver's instance variables: 

		text: 	a Text for '0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0...etc...

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		firstCharacterIndex: 	1

		container: 	(0@0) corner: (313@9999999)

		lines: 	an Array(a TextLine 1 to: 2 a TextLine 3 to: 4 a TextLine 5 to: 6 a Text...etc...

		positionWhenComposed: 	(0@0)

		offsetToEnd: 	17

		maxRightX: 	8

		selectionStart: 	a CharacterBlock with index 14772 and character Character cr an...etc...

		selectionStop: 	a CharacterBlock with index 14772 and character Character cr and...etc...

		wantsColumnBreaks: 	false

		focused: 	false

		caretRect: 	nil

		showCaret: 	nil

		findReplaceSelectionRegex: 	nil

		secondarySelection: 	nil

		extraSelectionBlocks: 	nil

		refreshExtraSelection: 	true

		composer: 	a TextComposer





SmalltalkEditor(TextEditor)>>zapSelectionWith:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aText: 	a Text for '
0'
		start: 	14772
		stop: 	14772

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(625999872)

		selectionShowing: 	true

		model: 	Transcript

		editingState: 	a SmalltalkEditingState





SmalltalkEditor(TextEditor)>>replace:with:and:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		xoldInterval: 	(14772 to: 14771)
		newText: 	a Text for '
0'
		selectingBlock: 	[  ]
		prevSel: 	a Text for ''
		currInterval: 	(14772 to: 14771)
		undoRec: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(625999872)

		selectionShowing: 	true

		model: 	Transcript

		editingState: 	a SmalltalkEditingState





SmalltalkEditor(TextEditor)>>replaceSelectionWith:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aText: 	a Text for '
0'

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(625999872)

		selectionShowing: 	true

		model: 	Transcript

		editingState: 	a SmalltalkEditingState





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>replaceSelectionWith:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aText: 	a Text for '
0'

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>appendEntry

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ self appendEntry ] in ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ result := editBlock value ] in ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		editBlock: 	[ self appendEntry ]
		result: 	nil

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(625999872)

	Arguments and temporary variables: 

		editBlock: 	[ result := editBlock value ]

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (313@118178)

		owner: 	a TransformMorph(639107072)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (313@118178)

		color: 	Color black

		extension: 	a MorphExtension (668729344) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for '0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	nil

		editView: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		result: 	nil
		editBlock: 	[ self appendEntry ]

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ super update: aSymbol ] in ThreadSafeTranscriptPluggableTextMorph>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





BlockClosure>>ensure:

	Receiver: [ super update: aSymbol ]

	Arguments and temporary variables: 

		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	ThreadSafeTranscriptPluggableTextMorph>>update:

		startpc: 	28

		numArgs: 	0





[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ super update: aSymbol ]
		activeProcess: 	a Process in Paragraph>>recomposeFrom:to:delta:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in Paragraph>>recomposeFrom:to:delta:





[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ super update: aSymbol ]
		activeProcess: 	a Process in Paragraph>>recomposeFrom:to:delta:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in Paragraph>>recomposeFrom:to:delta:





ThreadSafeTranscriptPluggableTextMorph>>update:

	Receiver: a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Arguments and temporary variables: 

		aSymbol: 	#appendEntry

	Receiver's instance variables: 

		bounds: 	(21.0@28.0) corner: (355.0@195.0)

		owner: 	a SystemWindow(92012544)

		submorphs: 	an Array(a ScrollBar(965738496) a TransformMorph(639107072))

		fullBounds: 	nil

		color: 	Color white

		extension: 	a MorphExtension (604766208) [locked]  [other:  (kmDispatcher -> a K...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	Transcript

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(965738496)

		scroller: 	a TransformMorph(639107072)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(856162304)

		textMorph: 	a TextMorphForEditView(625999872)

		getTextSelector: 	nil

		setTextSelector: 	nil

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(14772 to: 14771)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil

		mutex: 	a Mutex





[ :aDependent | aDependent update: aParameter ] in ThreadSafeTranscript(Object)>>changed:

	Receiver: Transcript

	Arguments and temporary variables: 

		aParameter: 	#appendEntry
		aDependent: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





DependentsArray>>do:

	Receiver: a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPluggableTextMorph(923271...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aDependent | aDependent update: aParameter ]
		dep: 	a ThreadSafeTranscriptPluggableTextMorph(923271168)
		i: 	2

	Receiver's instance variables: 

a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPluggableTextMorph(923271...etc...



ThreadSafeTranscript(Object)>>changed:

	Receiver: Transcript

	Arguments and temporary variables: 

		aParameter: 	#appendEntry

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





[ 
self changed: #appendEntry.
stream resetContents ] in ThreadSafeTranscript>>endEntry

	Receiver: Transcript

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





BlockClosure>>ensure:

	Receiver: [ 
self changed: #appendEntry.
stream resetContents ]

	Arguments and temporary variables: 

		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	ThreadSafeTranscript>>endEntry

		startpc: 	34

		numArgs: 	0





[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ 
self changed: #appendEntry.
stream resetContents ]
		activeProcess: 	a Process in Paragraph>>recomposeFrom:to:delta:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in Paragraph>>recomposeFrom:to:delta:





[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore()

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	nil

		lastLink: 	nil

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ 
self changed: #appendEntry.
stream resetContents ]
		activeProcess: 	a Process in Paragraph>>recomposeFrom:to:delta:

	Receiver's instance variables: 

		semaphore: 	a Semaphore()

		owner: 	a Process in Paragraph>>recomposeFrom:to:delta:





ThreadSafeTranscript>>endEntry

	Receiver: Transcript

	Arguments and temporary variables: 



	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





ThreadSafeTranscript>>show:

	Receiver: Transcript

	Arguments and temporary variables: 

		anObject: 	'0'

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





SmallInteger(Object)>>traceCr:

	Receiver: 0

	Arguments and temporary variables: 

		aString: 	'0'

	Receiver's instance variables: 

0



SmallInteger(Object)>>traceCr

	Receiver: 0

	Arguments and temporary variables: 



	Receiver's instance variables: 

0



[ #n binding traceCr ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

Paragraph>>recomposeFrom:to:delta:

Paragraph>>replaceFrom:to:with:

SmalltalkEditor(TextEditor)>>zapSelectionWith:

SmalltalkEditor(TextEditor)>>replace:with:and:

SmalltalkEditor(TextEditor)>>replaceSelectionWith:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>replaceSelectionWith:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>appendEntry

[ self appendEntry ] in ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

[ result := editBlock value ] in ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

TextMorphForEditView(TextMorph)>>handleEdit:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>handleEdit:

ThreadSafeTranscriptPluggableTextMorph(PluggableTextMorph)>>update:

[ super update: aSymbol ] in ThreadSafeTranscriptPluggableTextMorph>>update:

BlockClosure>>ensure:

[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscriptPluggableTextMorph>>update:

[ :aDependent | aDependent update: aParameter ] in ThreadSafeTranscript(Object)>>changed:

DependentsArray>>do:

ThreadSafeTranscript(Object)>>changed:

[ 
self changed: #appendEntry.
stream resetContents ] in ThreadSafeTranscript>>endEntry

BlockClosure>>ensure:

[ 
owner := activeProcess.
aBlock
	ensure: [ owner := nil ] ] in Mutex>>critical:

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscript>>endEntry

ThreadSafeTranscript>>show:

SmallInteger(Object)>>traceCr:

SmallInteger(Object)>>traceCr

[ #n binding traceCr ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 2:16:01.251934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...
		blockValue: 	nil
		caught: 	true

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





BlockClosure>>ensure:

	Receiver: [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ]

	Arguments and temporary variables: 

		aBlock: 	[ 
caught
	ifTrue: [ self signal ] ]
		complete: 	nil
		returnValue: 	nil

	Receiver's instance variables: 

		outerContext: 	Semaphore>>critical:

		startpc: 	42

		numArgs: 	0





Semaphore>>critical:

	Receiver: a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock...etc...

	Arguments and temporary variables: 

		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[ 
owner := activeProcess.
aBlock
	ensure: [ owner := ni...etc...

	Receiver's instance variables: 

		firstLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExc...etc...

		lastLink: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuallyExcl...etc...

		excessSignals: 	0





Mutex>>critical:

	Receiver: a Mutex

	Arguments and temporary variables: 

		aBlock: 	[ stream nextPutAll: value ]
		activeProcess: 	a Process in [ 
caught := true.
self wait.
blockValue := mutuall...etc...

	Receiver's instance variables: 

		semaphore: 	a Semaphore(a Process in [ 
caught := true.
self wait.
blockValue :=...etc...

		owner: 	a Process in Paragraph>>recomposeFrom:to:delta:





ThreadSafeTranscript>>nextPutAll:

	Receiver: Transcript

	Arguments and temporary variables: 

		value: 	'0'

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





ThreadSafeTranscript>>print:

	Receiver: Transcript

	Arguments and temporary variables: 

		anObject: 	'0'

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





ThreadSafeTranscript>>show:

	Receiver: Transcript

	Arguments and temporary variables: 

		anObject: 	'0'

	Receiver's instance variables: 

		dependents: 	a DependentsArray(a SystemWindow(92012544) a ThreadSafeTranscriptPl...etc...

		stream: 	a WriteStream

		accessSemaphore: 	a Mutex





SmallInteger(Object)>>traceCr:

	Receiver: 0

	Arguments and temporary variables: 

		aString: 	'0'

	Receiver's instance variables: 

0



SmallInteger(Object)>>traceCr

	Receiver: 0

	Arguments and temporary variables: 



	Receiver's instance variables: 

0



[ #n binding traceCr ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ #label1 binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#(#n 0))
		someCodeArray: 	an Array(an Array(#label1 [ #n binding traceCr ]) an Array(#labe...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: ...etc...
		resultBlock: 	[ lastVariable first bindTo: lastVariable second in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n binding traceCr ]))
		aBlock: 	[ #label1 binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n binding traceCr ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	0
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	0
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	0
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#n



[ lastVariable first bindTo: lastVariable second in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#(#n 0))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastVariable: 	#(#n 0)

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable first bindTo: lastVariable second in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable first bindTo: lastVariable second in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable first bindTo: lastVariable second in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#(#n 0))
		someCodeArray: 	an Array(an Array(#label1 [ #n binding traceCr ]) an Array(#labe...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: ...etc...
		resultBlock: 	[ lastVariable first bindTo: lastVariable second in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { {#n.0} } do:
{
{ #label1. [ #n binding traceC...etc...
		itsSelection: 	a Text for 'PROG withInit: { {#n.0} } do:
{
{ #label1. [ #n bindi...etc...
		itsSelectionString: 	'PROG withInit: { {#n.0} } do:
{
{ #label1. [ #n binding tr...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit:
			{{#n.
			0}}
		do:
			{{#label1.
			[ #n bindi...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(241434624)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(824.0@28.0) corner: (1264.0@195.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(824@28) corner: (1264@195)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 126)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(241434624)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (432@82)

		owner: 	a TransformMorph(393478144)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (432@82)

		color: 	Color black

		extension: 	a MorphExtension (302252032) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { {#n.0} } do:
{
{ #label1. [ #n binding trace...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	Color black

		editView: 	a PluggableTextMorph(485228544)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(485228544)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(824.0@28.0) corner: (1264.0@195.0)

		owner: 	a SystemWindow(365166592)

		submorphs: 	an Array(a TransformMorph(393478144))

		fullBounds: 	(824@28) corner: (1264@195)

		color: 	Color white

		extension: 	a MorphExtension (220200960) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(525074432)

		scroller: 	a TransformMorph(393478144)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(489422848)

		textMorph: 	a TextMorphForEditView(241434624)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	false

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 126)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(485228544)
		secondArg: 	a PluggableTextMorph(485228544)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(485228544)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(485228544)







--- The full stack ---

[ 
caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:

BlockClosure>>ensure:

Semaphore>>critical:

Mutex>>critical:

ThreadSafeTranscript>>nextPutAll:

ThreadSafeTranscript>>print:

ThreadSafeTranscript>>show:

SmallInteger(Object)>>traceCr:

SmallInteger(Object)>>traceCr

[ #n binding traceCr ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ #label1 binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable first bindTo: lastVariable second in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 3:12:14.111739 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ #label1 binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ #label1 binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
label binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
label binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
label binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ #label1 binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:12:56.839739 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		code...etc...

		pc: 	119

		stackp: 	2

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
label binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		cod...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBl...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
label binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		label binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

SubscriptOutOfBounds: 0

29 November 2018 3:17:14.774739 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



Array(Object)>>errorSubscriptBounds:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(Object)>>at:

	Receiver: #()

	Arguments and temporary variables: 

		index: 	0

	Receiver's instance variables: 

#()



Array(SequenceableCollection)>>last

	Receiver: #()

	Arguments and temporary variables: 



	Receiver's instance variables: 

#()



PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	in:...etc...
		newBlock: 	nil
		lastLine: 	an Array(#label1 [ #n changeBinding: 0 ])
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1
		nextLine: 	nil
		nextLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	in:...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	i...etc...
		lastLine: 	an Array(#label2 [ 
Halt halt.
#n changeBinding: #n binding + 1 ])
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		nextLine: 	an Array(#label1 [ #n changeBinding: 0 ])
		nextLabel: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	in:...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	i...etc...
		lastLine: 	an Array(#label3 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		nextLine: 	an Array(#label2 [ 
Halt halt.
#n changeBinding: #n binding + 1 ])
		nextLabel: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	in:...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	i...etc...
		lastLine: 	an Array(#label4 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		nextLine: 	an Array(#label3 [ #n changeBinding: #n binding + 1 ])
		nextLabel: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	in:...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	i...etc...
		lastLine: 	an Array(#label5 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		nextLine: 	an Array(#label4 [ #n changeBinding: #n binding + 1 ])
		nextLabel: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		nextLabel binding value ]
	i...etc...
		lastLine: 	an Array(#label6 [ #n changeBinding: #n binding + 1 ])
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		nextLine: 	an Array(#label5 [ #n changeBinding: #n binding + 1 ])
		nextLabel: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ #label1 binding value ]
		newBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]...etc...
		lastLine: 	an Array(#label7 [ #RETURN binding value: #n binding ])
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		nextLine: 	an Array(#label6 [ #n changeBinding: #n binding + 1 ])
		nextLabel: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true





PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	nil
		resultBlock: 	nil
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	132

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



OpalCompiler>>evaluate

	Receiver: an OpalCompiler

	Arguments and temporary variables: 

		value: 	nil
		selectedSource: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0 ...etc...
		itsSelection: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBi...etc...
		itsSelectionString: 	'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding...etc...

	Receiver's instance variables: 

		ast: 	DoIt
	^ PROG
		withInit: {#n}
		do:
			{{#label1.
			[ #n changeBinding: 0...etc...

		source: 	a ReadStream

		context: 	nil

		receiver: 	nil

		compilationContext: 	a CompilationContext

		compilationContextClass: 	nil

		useFaultyForParsing: 	false





SmalltalkEditor>>evaluateSelectionAndDo:

	Receiver: a SmalltalkEditor

	Arguments and temporary variables: 

		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil

	Receiver's instance variables: 

		morph: 	a TextMorphForEditView(927203328)

		selectionShowing: 	true

		model: 	a Workspace

		editingState: 	a SmalltalkEditingState





[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(736886784)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(373.0@28.0) corner: (813.0@195.0)

		owner: 	a SystemWindow(825753600)

		submorphs: 	an Array(a ScrollBar(776732672) a TransformMorph(397934592))

		fullBounds: 	(373@28) corner: (813@195)

		color: 	Color white

		extension: 	a MorphExtension (905969664) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(776732672)

		scroller: 	a TransformMorph(397934592)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(548143104)

		textMorph: 	a TextMorphForEditView(927203328)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 411)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





TextMorphForEditView(TextMorph)>>handleEdit:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil





PluggableTextMorph>>printIt

	Receiver: a PluggableTextMorph(736886784)

	Arguments and temporary variables: 

		oldEditor: 	a SmalltalkEditor
		printString: 	nil

	Receiver's instance variables: 

		bounds: 	(373.0@28.0) corner: (813.0@195.0)

		owner: 	a SystemWindow(825753600)

		submorphs: 	an Array(a ScrollBar(776732672) a TransformMorph(397934592))

		fullBounds: 	(373@28) corner: (813@195)

		color: 	Color white

		extension: 	a MorphExtension (905969664) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	1

		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)

		model: 	a Workspace

		open: 	false

		accessor: 	nil

		scrollBar: 	a ScrollBar(776732672)

		scroller: 	a TransformMorph(397934592)

		getMenuSelector: 	#codePaneMenu:shifted:

		getMenuTitleSelector: 	nil

		hasFocus: 	false

		hScrollBar: 	a ScrollBar(548143104)

		textMorph: 	a TextMorphForEditView(927203328)

		getTextSelector: 	#contents

		setTextSelector: 	#acceptContents:

		getSelectionSelector: 	nil

		hasUnacceptedEdits: 	true

		askBeforeDiscardingEdits: 	true

		selectionInterval: 	(1 to: 411)

		hasEditingConflicts: 	false

		acceptAction: 	nil

		getColorSelector: 	nil

		unstyledAcceptText: 	nil

		styler: 	a SHTextStylerST80

		autoAccept: 	nil

		enabled: 	true

		getEnabledSelector: 	nil

		highlights: 	an OrderedCollection()

		acceptOnFocusChange: 	nil

		selectionColor: 	nil

		alwaysAccept: 	nil

		changedAction: 	nil

		doubleClickSelector: 	nil

		setSelectionSelector: 	nil





[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

	Receiver: SmalltalkEditor

	Arguments and temporary variables: 

		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(736886784)

	Receiver's instance variables: 

		superclass: 	TextEditor

		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...

		format: 	138

		layout: 	a FixedLayout

		instanceVariables: 	nil

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#SmalltalkEditor

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#'Text-Edition'

		traitComposition: 	{}

		localSelectors: 	nil

		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...

		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...





BlockClosure>>cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		anArg: 	a PluggableTextMorph(736886784)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(736886784)
		secondArg: 	a PluggableTextMorph(736886784)

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





BlockClosure>>cull:cull:cull:

	Receiver: [ :morph | morph printIt ]

	Arguments and temporary variables: 

		firstArg: 	a PluggableTextMorph(736886784)
		secondArg: 	a PluggableTextMorph(736886784)
		thirdArg: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

		startpc: 	277

		numArgs: 	1





KMCategoryBinding>>completeMatch:buffer:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(736886784)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(736886784)





[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





Array(SequenceableCollection)>>do:

	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Arguments and temporary variables: 

		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1

	Receiver's instance variables: 

an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)



KMKeymap>>notifyCompleteMatchTo:buffer:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





KMKeymap>>onMatchWith:notify:andDo:

	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]


	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		action: 	[ :morph | morph printIt ]

		name: 	#printIt

		shortcut: 	Ctrl + P

		defaultShortcut: 	Ctrl + P

		description: 	''





[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





Set>>do:

	Receiver: a Set(#previousSibling on Ctrl + U do [ :morph | morph standOutPreviousChild ]
 #parent on...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	19
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]


	Receiver's instance variables: 

		tally: 	14

		array: 	an Array(#previousSibling on Ctrl + U do [ :morph | morph standOutPrevio...etc...





KMCategory>>onMatchWith:notify:andDo:

	Receiver: a KMCategory

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]

	Receiver's instance variables: 

		name: 	#SmalltalkEditor

		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...





KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

	Receiver: aKMCategoryTarget(#SmalltalkEditor)

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]

	Receiver's instance variables: 

		target: 	a PluggableTextMorph(736886784)

		category: 	a KMCategory

		morph: 	a PluggableTextMorph(736886784)





[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextMorphTab) a...etc...

		morph: 	a PluggableTextMorph(736886784)

		directKeymaps: 	a KMCategory





OrderedCollection>>do:

	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...

	Arguments and temporary variables: 

		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7

	Receiver's instance variables: 

		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...

		firstIndex: 	1

		lastIndex: 	7





KMDispatcher>>dispatch:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextMorphTab) a...etc...

		morph: 	a PluggableTextMorph(736886784)

		directKeymaps: 	a KMCategory





KMTarget>>dispatch:

	Receiver: a KMTarget

	Arguments and temporary variables: 

		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])

	Receiver's instance variables: 

		realTarget: 	nil

		morph: 	a PluggableTextMorph(736886784)

		targetSelector: 	#yourself

		directKeymaps: 	nil

		perInstanceCategories: 	nil





[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>do:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatchChain>>dispatch:

	Receiver: a KMDispatchChain

	Arguments and temporary variables: 

		aKeyboardEvent: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		target: 	a KMTarget

		dispatcher: 	a KMDispatcher

		initialTarget: 	a KmGlobalDispatcher





KMDispatcher>>dispatchKeystroke:

	Receiver: a KMDispatcher

	Arguments and temporary variables: 

		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain

	Receiver's instance variables: 

		target: 	a KMTarget

		currentEvent: 	nil

		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...

		morph: 	a TextMorphForEditView(927203328)

		directKeymaps: 	a KMCategory





TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

	Receiver: a TextMorphForEditView(927203328)

	Arguments and temporary variables: 

		evt: 	[keystroke '<Ctrl-p>']

	Receiver's instance variables: 

		bounds: 	(0@0) corner: (419@178)

		owner: 	a TransformMorph(397934592)

		submorphs: 	#()

		fullBounds: 	(0@0) corner: (419@178)

		color: 	Color black

		extension: 	a MorphExtension (981991424) [other:  (kmDispatcher -> a KMDispatche...etc...

		borderWidth: 	0

		borderColor: 	Color black

		textStyle: 	a TextStyle Bitmap DejaVu Sans 9

		text: 	a Text for 'PROG withInit: { #n } do:
{
{ #label1 . [ #n changeBinding: 0...etc...

		wrapFlag: 	true

		paragraph: 	a Paragraph

		editor: 	a SmalltalkEditor

		container: 	nil

		predecessor: 	nil

		successor: 	nil

		backgroundColor: 	nil

		margins: 	(0@0) corner: (0@0)

		defaultColor: 	a TextColor code: Color black

		editView: 	a PluggableTextMorph(736886784)

		acceptOnCR: 	false

		autoAccept: 	false

		acceptOnFocusChange: 	false

		selectionColor: 	nil







--- The full stack ---

Array(Object)>>errorSubscriptBounds:

Array(Object)>>at:

Array(SequenceableCollection)>>last

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

PROG>>addCode:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

MessageNotUnderstood: BlockClosure>>first

29 November 2018 3:22:50.747911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



BlockClosure(Object)>>doesNotUnderstand: #first

	Receiver: [ #n changeBinding: 0 ]

	Arguments and temporary variables: 

		aMessage: 	first
		exception: 	MessageNotUnderstood: BlockClosure>>first
		resumeValue: 	nil

	Receiver's instance variables: 

		outerContext: 	UndefinedObject>>DoIt

		startpc: 	74

		numArgs: 	0





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





[ #label1 binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLine)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ #label1 binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ #label1 binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#label2 ...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLine first binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLine first binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLine first binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	[ #n changeBinding: 0 ]





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ #n changeBinding: 0 ]) an Array(#lab...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding ...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLine)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

BlockClosure(Object)>>doesNotUnderstand: #first

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ #label1 binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:23:16.934911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine v...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bind...etc...

		pc: 	119

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLine first binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bin...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:23:41.364911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext>>receiver

	Receiver: [ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine v...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bind...etc...

		pc: 	119

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLine first binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bin...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])







--- The full stack ---

MethodContext>>receiver

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:23:41.934911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ delaySemaphore wait ] in Delay>>wait

	Receiver: a Delay(14 msecs)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		delayDuration: 	14

		resumptionTime: 	154614

		delaySemaphore: 	a Semaphore()

		beingWaitedOn: 	false





BlockClosure>>ifCurtailed:

	Receiver: [ delaySemaphore wait ]

	Arguments and temporary variables: 

		aBlock: 	[ self unschedule ]
		complete: 	nil
		result: 	nil

	Receiver's instance variables: 

		outerContext: 	Delay>>wait

		startpc: 	36

		numArgs: 	0





Delay>>wait

	Receiver: a Delay(14 msecs)

	Arguments and temporary variables: 



	Receiver's instance variables: 

		delayDuration: 	14

		resumptionTime: 	154614

		delaySemaphore: 	a Semaphore()

		beingWaitedOn: 	false





WorldState>>interCyclePause:

	Receiver: a WorldState

	Arguments and temporary variables: 

		milliSecs: 	20
		currentTime: 	154600
		wait: 	14

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(557580288))(a Spec...etc...

		lastStepTime: 	154594

		lastStepMessage: 	nil

		lastCycleTime: 	154594

		alarms: 	a Heap()

		lastAlarmTime: 	154594

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





WorldState>>doOneCycleFor:

	Receiver: a WorldState

	Arguments and temporary variables: 

		aWorld: 	a WorldMorph(511705088) [world]

	Receiver's instance variables: 

		hands: 	an Array(a HandMorph(760479744))

		viewBox: 	(0@0) corner: (1520@785)

		canvas: 	a FormCanvas on: DisplayScreen(1520x785x32)

		damageRecorder: 	a DamageRecorder

		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(557580288))(a Spec...etc...

		lastStepTime: 	154594

		lastStepMessage: 	nil

		lastCycleTime: 	154594

		alarms: 	a Heap()

		lastAlarmTime: 	154594

		menuBuilder: 	a PragmaMenuBuilder ( nil ) 





WorldMorph>>doOneCycle

	Receiver: a WorldMorph(511705088) [world]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		bounds: 	(0@0) corner: (1520@785)

		owner: 	nil

		submorphs: 	an Array(a MenuMorph(894959616) a TaskbarMorph(984088576) a SpecWind...etc...

		fullBounds: 	nil

		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)

		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...

		borderWidth: 	0

		borderColor: 	(Color r: 0.063 g: 0.063 b: 0.063 alpha: 1.0)

		backgroundMorph: 	nil

		worldState: 	a WorldState

		griddingOn: 	nil





[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

	Receiver: a MorphicUIManager

	Arguments and temporary variables: 



	Receiver's instance variables: 

		interactiveParser: 	nil

		activeTranscript: 	Transcript





[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

	Receiver: [ 
World doOneCycle.
Processor yield.
false ]

	Arguments and temporary variables: 



	Receiver's instance variables: 

		outerContext: 	MorphicUIManager>>spawnNewProcess

		startpc: 	65

		numArgs: 	0







--- The full stack ---

[ delaySemaphore wait ] in Delay>>wait

BlockClosure>>ifCurtailed:

Delay>>wait

WorldState>>interCyclePause:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:24:36.826911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(Object)>>=

	Receiver: [ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine v...etc...

	Arguments and temporary variables: 

		anObject: 	nil

	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bind...etc...

		pc: 	123

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLine first binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bin...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])







--- The full stack ---

MethodContext(Object)>>=

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:28:22.162911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bin...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])







--- The full stack ---

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:29:54.672911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine v...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bind...etc...

		pc: 	126

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLine first binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bin...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])





[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding val...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLine: 	an Array(#label1 [ #n changeBinding: 0 ])







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLine first binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLine first binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:33:15.538911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext>>receiver

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext>>receiver

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:33:45.150911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:34:55.732911 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(Object)>>=

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 

		anObject: 	nil

	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(Object)>>=

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:40:45.098811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PR...etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	Binding>>of:to:in:

		pc: 	129

		stackp: 	3

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding va...etc...

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:43:53.476811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	126

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:44:49.112811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(Object)>>=

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 

		anObject: 	nil

	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(Object)>>=

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:46:45.457811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



PROG(Object)>>isMemberOf:

	Receiver: a PROG

	Arguments and temporary variables: 

		aClass: 	Binding

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





ByteSymbol(Symbol)>>binding

	Receiver: #label1

	Arguments and temporary variables: 

		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#label1



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

PROG(Object)>>isMemberOf:

ByteSymbol(Symbol)>>binding

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:48:00.245811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

User Interrupt

29 November 2018 3:50:38.473811 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



MethodContext(ContextPart)>>sender

	Receiver: [ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value....etc...

	Arguments and temporary variables: 



	Receiver's instance variables: 

		sender: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [...etc...

		pc: 	118

		stackp: 	1

		method: 	PROG>>#addCode:in:

		closureOrNil: 	[ 
codeLine value.
previousLabel binding value ]

		receiver: 	a PROG





ByteSymbol(Symbol)>>changeBinding:

	Receiver: #n

	Arguments and temporary variables: 

		anObject: 	0
		context: 	[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: ...etc...

	Receiver's instance variables: 

#n



[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

MethodContext(ContextPart)>>sender

ByteSymbol(Symbol)>>changeBinding:

[ #n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

-- and more not shown ---------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 3:54:23.187934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 3:58:45.218934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:00:54.284934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:38.555934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:40.578934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN





--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:41.928934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:42.945934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:43.969934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:04:45.816934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

<<error during printing>

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n





--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:09:56.384934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:11:49.876934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:11:51.387934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN





--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:11:52.351934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:11:53.287934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:34.912934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:36.422934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN





--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:37.103934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:37.770934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:38.458934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:39.681934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#n





--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:12:41.308934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
previousLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
previousLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
previousLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
previousLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		previousLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:13:18.535934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	i...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->nil

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	nil





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN



PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	i...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil







--- The full stack ---

[ 
Halt halt.
#n changeBinding: 0 ] in UndefinedObject>>DoIt

[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

PROG class>>withInit:do:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



THERE_BE_DRAGONS_HERE

Halt

29 November 2018 4:13:19.898934 pm



VM: Win32 - IX86 - 6.2 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826


Image: Pharo3.0 [Latest update: #30864]



[ 
Halt halt.
#n changeBinding: #n binding + 1 ] in UndefinedObject>>DoIt

	Receiver: nil

	Arguments and temporary variables: 



	Receiver's instance variables: 

nil



[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





[ someCodeArray first first binding value ] in PROG class>>withInit:do:

	Receiver: PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		someCodeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) a...etc...
		prog: 	a PROG
		codeBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	i...etc...
		resultBlock: 	[ lastVariable bindTo: nil in: aBlock ]
		ret: 	a Continuation

	Receiver's instance variables: 

		superclass: 	Object

		methodDict: 	a MethodDictionary(#addCode:in:->PROG>>#addCode:in: #addVariables:i...etc...

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#(#lastCodeDone #previousLabel)

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#PROG

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#Practica

		traitComposition: 	{}

		localSelectors: 	nil





Binding>>of:to:in:

	Receiver: #label7->[ 
codeLine value.
#RETURN binding value: nil ]

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		key: 	#label7

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label7
		aValue: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label7

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
#RETURN binding value: nil ]
		aBlock: 	[ someCodeArray first first binding value ]

	Receiver's instance variables: 

#label7



[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ someCodeArray first first binding value ]
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #RETURN binding value: #n binding ]
		label: 	#label7
		theLabel: 	nil

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label6->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		key: 	#label6

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label6
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label6

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...

	Receiver's instance variables: 

#label6



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label6
		theLabel: 	#label7

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label5->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label5

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label5
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label5

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label5



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label5
		theLabel: 	#label6

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label4->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label4

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label4
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label4

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label4



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label4
		theLabel: 	#label5

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label3->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label3

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label3
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label3

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label3



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]) an Ar...etc...
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ #n changeBinding: #n binding + 1 ]
		label: 	#label3
		theLabel: 	#label4

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label2->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label2

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label2
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label2

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label2



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	an Array(an Array(#label1 [ 
Halt halt.
#n changeBinding: 0 ]))
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: #n binding + 1 ]
		label: 	#label2
		theLabel: 	#label3

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #label1->[ 
codeLine value.
theLabel binding value ]

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#label1

		value: 	[ 
codeLine value.
theLabel binding value ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#label1
		aValue: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #label1

	Arguments and temporary variables: 

		value: 	[ 
codeLine value.
theLabel binding value ]
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#label1



[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		codeArray: 	#()
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastLine: 	nil
		codeLine: 	[ 
Halt halt.
#n changeBinding: 0 ]
		label: 	#label1
		theLabel: 	#label2

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #n->0

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		key: 	#n

		value: 	0





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#n
		aValue: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #n

	Arguments and temporary variables: 

		value: 	nil
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...

	Receiver's instance variables: 

#n



[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

	Receiver: a PROG

	Arguments and temporary variables: 

		someVariablesArray: 	#(#n)
		aBlock: 	[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: ...etc...
		newBlock: 	nil
		lastVariable: 	#n

	Receiver's instance variables: 

		lastCodeDone: 	true

		previousLabel: 	#label1





Binding>>of:to:in:

	Receiver: #RETURN->[ :val | ret value: val ]

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		key: 	#RETURN

		value: 	[ :val | ret value: val ]





Binding class>>of:to:in:

	Receiver: Binding

	Arguments and temporary variables: 

		aSymbol: 	#RETURN
		aValue: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

		superclass: 	Association

		methodDict: 	a MethodDictionary(#of:to:in:->Binding>>#of:to:in: )

		format: 	134

		layout: 	a FixedLayout

		instanceVariables: 	#()

		organization: 	a ClassOrganization

		subclasses: 	nil

		name: 	#Binding

		classPool: 	a Dictionary()

		sharedPools: 	an OrderedCollection()

		environment: 	a SystemDictionary(lots of globals)

		category: 	#DeutschByte

		traitComposition: 	{}

		localSelectors: 	nil





ByteSymbol(Symbol)>>bindTo:in:

	Receiver: #RETURN

	Arguments and temporary variables: 

		value: 	[ :val | ret value: val ]
		aBlock: 	[ lastVariable bindTo: nil in: aBlock ]

	Receiver's instance variables: 

#RETURN





--- The full stack ---

[ 
Halt halt.
#n changeBinding: #n binding + 1 ] in UndefinedObject>>DoIt

[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ 
codeLine value.
theLabel binding value ] in [ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

[ someCodeArray first first binding value ] in PROG class>>withInit:do:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		#RETURN binding value: nil ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ 
label
	bindTo: [ 
		codeLine value.
		theLabel binding value ]
	in: aBlock ] in PROG>>addCode:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

[ lastVariable bindTo: nil in: aBlock ] in PROG>>addVariables:in:

Binding>>of:to:in:

Binding class>>of:to:in:

ByteSymbol(Symbol)>>bindTo:in:

 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -

PROG class>>withInit:do:

UndefinedObject>>DoIt

OpalCompiler>>evaluate

SmalltalkEditor>>evaluateSelectionAndDo:

[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt

TextMorphForEditView(TextMorph)>>handleEdit:

PluggableTextMorph>>printIt

[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:

BlockClosure>>cull:

BlockClosure>>cull:cull:

BlockClosure>>cull:cull:cull:

KMCategoryBinding>>completeMatch:buffer:

[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:

Array(SequenceableCollection)>>do:

KMKeymap>>notifyCompleteMatchTo:buffer:

KMKeymap>>onMatchWith:notify:andDo:

[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:

Set>>do:

KMCategory>>onMatchWith:notify:andDo:

KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:

[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:

OrderedCollection>>do:

KMDispatcher>>dispatch:

KMTarget>>dispatch:

[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:

KMDispatchChain>>do:

KMDispatchChain>>dispatch:

KMDispatcher>>dispatchKeystroke:

TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:

TextMorphForEditView(TextMorph)>>handleKeystroke:

KeyboardEvent>>sentTo:

TextMorphForEditView(Morph)>>handleEvent:

TextMorphForEditView(Morph)>>handleFocusEvent:

[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:

BlockClosure>>on:do:

WorldMorph(PasteUpMorph)>>becomeActiveDuring:

HandMorph>>sendFocusEvent:to:clear:

HandMorph>>sendEvent:focus:clear:

HandMorph>>sendKeyboardEvent:

HandMorph>>handleEvent:

HandMorph>>processEvents

[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:

Array(SequenceableCollection)>>do:

WorldState>>handsDo:

WorldState>>doOneCycleNowFor:

WorldState>>doOneCycleFor:

WorldMorph>>doOneCycle

[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess

[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess

-------------------------------------------------------------------------------



