Object subclass: #PROG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Practica'!!PROG commentStamp: '<historical>' prior: 0!A BASIC is a class to execute code in a BASIC like syntaxis.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PROG class	instanceVariableNames: ''!!PROG class methodsFor: 'codeExecution' stamp: 'FernandezCodina 12/2/2018 10:55'!addCode: codeArray in: aBlock previousLabel: theLabel	| newBlock lastLine codeLine label |	lastLine := codeArray last.	codeLine := lastLine second.	label := lastLine first.	codeArray := codeArray first: (codeArray size - 1).	newBlock := [label bindTo: [ codeLine value. theLabel binding value] in: aBlock ].	(codeArray size ~= 0) ifTrue: [^self addCode: codeArray in: newBlock previousLabel: label]						ifFalse: [^newBlock]! !!PROG class methodsFor: 'codeExecution' stamp: 'FernandezCodina 12/2/2018 10:57'!addVariables: someVariablesArray in: aBlock 		| newBlock lastVariable |	lastVariable := someVariablesArray last.	(lastVariable class = Array) ifTrue: [newBlock := [lastVariable first bindTo: lastVariable second in: aBlock ] ]	                                          ifFalse: [newBlock := [lastVariable bindTo: nil in: aBlock]].	someVariablesArray := someVariablesArray first: (someVariablesArray size - 1).	someVariablesArray size ~= 0 ifTrue: [^self addVariables: someVariablesArray in: newBlock]	                                               ifFalse: [^newBlock ]	! !!PROG class methodsFor: 'codeExecution' stamp: 'FernandezCodina 12/2/2018 10:53'!addCode: codeArray in: aBlock	| newBlock lastLine codeLine label |	lastLine := codeArray last.	codeLine := lastLine second.	label := lastLine first.	codeArray := codeArray first: (codeArray size - 1).		newBlock := [label bindTo: [codeLine value. #RETURN binding value: nil] in: aBlock ]. 								(codeArray size ~= 0) ifTrue: [^self addCode: codeArray in: newBlock previousLabel: label]						ifFalse:[^newBlock]! !!PROG class methodsFor: 'codeExecution' stamp: 'FernandezCodina 12/31/2018 17:04'!withInit: someVariablesArray do: someCodeArray	| codeBlock resultBlock ret|	ret := Continuation callcc: [ :cc | cc].	(ret class = Continuation)				ifTrue: [					codeBlock := PROG addCode: someCodeArray in: [someCodeArray first first binding value].					resultBlock := PROG addVariables: someVariablesArray  in: codeBlock.					#RETURN bindTo: [ :val | ret value: val ] in: resultBlock.]				ifFalse: [^ret]. ! !TestCase subclass: #PracticaTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Practica'!!PracticaTest methodsFor: 'as yet unclassified' stamp: 'FernandezCodina 12/31/2018 17:05'!testContinuationsself assert: (PROG withInit: { #x } do: { { #label1 . [ #x changeBinding: (Continuation callcc: [ :cc| cc value: true ] )] }.{ #label2 . [ #RETURN binding value: #x binding ] } }).self assert: (PROG withInit: { #x . #continuation } do: { { #label1 . [ #x changeBinding: (Continuation callcc: [ :cc | #continuation changeBinding: cc. false ] )] }.{ #label2 . [#x binding ifFalse:[ #continuation binding value: true] ] }.{ #label3 . [ #RETURN binding value: (#x binding)] } }).self assert: (PROG withInit: { #assoc } do: { { #label1 . [ #assoc changeBinding: (Continuation callcc: [ :cc | cc -> 0 ] ) ] }.{ #label2 . [ #assoc binding value: (#assoc binding value + 1) ] } .{ #label3 . [ #assoc binding value = 4 ifFalse: [ #assoc binding key value: (#assoc binding) ]. ] } .{ #label4 . [ #RETURN binding value: (#assoc binding value) ] } } ) = 4! !!PracticaTest methodsFor: 'as yet unclassified' stamp: 'FernandezCodina 12/31/2018 17:05'!testFactorialself assert: (PROG withInit: { { #n . 10 } . #factorial } do: { { #label1 . [ #factorial changeBinding: 1 ] } .{ #label2 . [ #n binding = 0 ifTrue: [#RETURN binding value: #factorial binding] ] }.{ #label3 . [ #factorial changeBinding: (#factorial binding * #n binding) ] }.{ #label4 . [ #n changeBinding: (#n binding - 1) ] }.{ #label5 . [ #label2 binding value ] } } ) = (10 factorial)! !!PracticaTest methodsFor: 'as yet unclassified' stamp: 'FernandezCodina 12/31/2018 17:06'!testVariableBinding|block |block:= [self assert: #b binding = nil. self assert: #a binding = 2 ].block := PROG addVariables: { #b .{#a . 2} } in: block.block value.! !!PracticaTest methodsFor: 'as yet unclassified' stamp: 'FernandezCodina 12/31/2018 17:05'!testAnyLabel"Testing that the code accepts any label if they arent repeated"self assert: (PROG withInit: { #n } do:{{ #label1 . [ #n changeBinding: 0 ] } .{ #lblae2 . [ #n changeBinding: (#n binding + 1) ] } .{ #alskdjfalkdsjfalñkdjfañlskdj . [ #n changeBinding: (#n binding + 1) ] } .{ #etiqueta50000 . [ #n changeBinding: (#n binding + 1) ] } .{ #label2 . [ #n changeBinding: (#n binding + 1) ] } .{ #theLabel . [ #n changeBinding: (#n binding + 1) ] } .{ #label7 . [ #RETURN binding value: #n binding  ] } .}) = 5.  ! !!PracticaTest methodsFor: 'as yet unclassified' stamp: 'FernandezCodina 11/25/2018 19:03'!testChangeBinding#a bindTo: 1 in: [ 	self assert: #a binding = 1.	#a changeBinding: 2.	self assert: #a binding = 2	 ] ! !'From Pharo3.0 of 18 March 2013 [Latest update: #30864] on 31 December 2018 at 6:44:43.688053 pm'!!Symbol methodsFor: '*Practica' stamp: 'FernandezCodina 11/25/2018 19:01'!changeBinding: anObject	| context |	context := thisContext.	[ context = nil ] whileFalse:		[   ((context receiver isMemberOf: Binding)				and: [ context selector = #of:to:in:					and: [context receiver key = self]])				ifTrue: [context receiver value: anObject. ^nil]				ifFalse: [context := context sender]		].	self error: 'No binding for ', self asString.! !